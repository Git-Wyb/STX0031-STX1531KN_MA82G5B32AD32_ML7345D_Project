C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE KEY_AND_OTHER
OBJECT MODULE PLACED IN .\Objects\key_and_Other.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE user\src\key_and_Other.c OPTIMIZE(0,SPEED) BROWSE INCDIR(.\include;.\use
                    -r\inc) DEBUG OBJECTEXTEND PRINT(.\Listings\key_and_Other.lst) OBJECT(.\Objects\key_and_Other.obj)

line level    source

   1          /***********************************************************************/
   2          /*  FILE        :key_and_Other.c                                       */
   3          /*  DATE        :Mar, 2014                                             */
   4          /*  Programmer  :xiang 'R                                              */
   5          /*  CPU TYPE    :STM8S003     Crystal: 4M HSI                          */
   6          /*  DESCRIPTION :                                                      */
   7          /*  Mark        :ver 1.0                                               */
   8          /***********************************************************************/ 
   9          #include "key_and_Other.h"              // 按键
  10          
  11          void key_check(void)
  12          {
  13   1      //    if (TB_100ms)--TB_100ms;
  14   1      //    else{                            
  15   1      //        TB_100ms = BASE_100ms;
  16   1      //        FG_100ms = 1;       // 100mS FLAG
  17   1      //      }
  18   1        
  19   1        
  20   1         if(FG_1ms){
  21   2          FG_1ms=0; 
  22   2          if(TIME_power_on_AD)TIME_power_on_AD--;
  23   2          if(m_TimerRegMode)--m_TimerRegMode;        
  24   2          if(m_KeyDupliSetTimeout)--m_KeyDupliSetTimeout;
  25   2          if(m_TimerKeyMonitor)--m_TimerKeyMonitor;
  26   2          if(m_KeyDupli1stTimer)--m_KeyDupli1stTimer;
  27   2          else FG_d_StopKey=0;
  28   2          if  ( FG_d_StopKey &&m_KeyDupli1stTimer){
  29   3            time_led++;
  30   3            if(time_led>=90){time_led=0;PIN_LED=!PIN_LED;}
  31   3          }
  32   2          if(m_TimerKey)--m_TimerKey;
  33   2          
  34   2          if(TIME_BEEP_on)
  35   2          {
  36   3              //--TIME_BEEP_on;
  37   3              if(FG_beep_on==0)
  38   3              {
  39   4                  FG_beep_on=1;FG_beep_off=0;Beep_On();//BEEP_CSR2_BEEPEN=1; //2015.3.11修正
  40   4                  if(FG_LED_on)   PIN_LED=1;
  41   4              }
  42   3          }
  43   2          else if(TIME_BEEP_off)
  44   2          {
  45   3              //--TIME_BEEP_off;
  46   3              if(FG_beep_off==0)
  47   3              {
  48   4                  FG_beep_off=1;FG_beep_on=0;Beep_Off();//BEEP_CSR2_BEEPEN=0;  //2015.3.11修正
  49   4                  if(FG_LED_on)   PIN_LED=0;
  50   4              }
  51   3          }
  52   2          else if(TIME_BEEP_freq)
  53   2          {
  54   3              --TIME_BEEP_freq;
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 2   

  55   3              TIME_BEEP_on=BASE_TIME_BEEP_on;
  56   3              TIME_BEEP_off=BASE_TIME_BEEP_off;
  57   3              if(FG_beep_on==0)
  58   3              {
  59   4                  FG_beep_on=1;FG_beep_off=0;Beep_On();//BEEP_CSR2_BEEPEN=1;  //2015.3.11修正
  60   4                  if(FG_LED_on)PIN_LED=1;
  61   4              }      
  62   3          }
  63   2          else  FG_LED_on=0; 
  64   2          
  65   2      //    if(FG_BAT_value==0){START_AD_SAMPLER();FG_BAT_value=1;}
  66   2      //    else {ADC_read();FG_BAT_value=0;}
  67   2          _KeyInTx();
  68   2          if(FG_10s==1) return;   // 2015.1.31修正3
  69   2          _RegistrationMode();
  70   2          _DupliFuncSetMode();
  71   2          //ADC2_EOC_INT();
  72   2          ClearWDT(); // Service the WDT    
  73   2        }
  74   1      }
  75          
  76          
  77          void time_control(void)
  78          {
  79   1          if(FG_100ms){
  80   2              FG_100ms=0; 
  81   2              if(TIME_2s_RestTX)--TIME_2s_RestTX;    //2015.4.13修正    
  82   2              if(FG_PWRON==1){
  83   3                  if ((TB_5s)&&(m_KeyOptSetMode==0))  --TB_5s;
  84   3              }    
  85   2          }
  86   1          if(Time_Tx_Out == 0 && FLAG_APP_TX == 1)
  87   1          {
  88   2              FLAG_APP_TX = 0;
  89   2              if(FG_d_StopKey == 0)   PIN_TX_LED = 0;
  90   2              ML7345_SetAndGet_State(Force_TRX_OFF);
  91   2              ML7345_RESETN = 0;
  92   2              SpiGpio_UnInit();
  93   2              ML7345D_POWER = FG_NOT_allow_out;
  94   2          }
  95   1      }
  96          
  97          //
  98          /****************************************/
  99          /*                                                                              */
 100          /*                      Check Key for Tx                        */
 101          /*                                                                              */
 102          /*                        in  : none                            */
 103          /*                        out : none                            */
 104          /*                                                                              */
 105          /****************************************/
 106          //
 107          /*      Key data table  */
 108          //              ||||||||
 109          //              |||||||+ Auto Tx Stop
 110          //              ||||||++ Auto Tx Start
 111          //              |||||+++ Reg.
 112          //              ||||++++ Vent.
 113          //              |||+++++ Close
 114          //              ||++++++ Stop
 115          //              |+++++++ Open
 116          //              ++++++++ 1
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 3   

 117          //
 118          const   uchar   ct_KeyDataTable[]
 119          ={ 
 120                  /*      Reg. (0)        */
 121          0xFB,// 0b11111011,
 122          //      /*      Open (1)        */
 123          0xBF,// 0b10111111,
 124          //      /*      Stop (2)        */
 125          0xDF,// 0b11011111,
 126          //      /*      Close (3)       */
 127          0xEF,// 0b11101111,
 128          //      /*      Vent. (4)       */
 129          0xF7,// 0b11110111,
 130          //      /*      Open + Stop (5) */
 131          0x9F,// 0b10011111,
 132          //      /*      Open + Close (6)        */
 133          0xAF,// 0b10101111,
 134          //      /*      Open + Vent. (7)        */
 135          0xB7,// 0b10110111,
 136          //      /*      Open + Reg. (8) */
 137          0xBB,// 0b10111011,
 138          //      /*      Stop + Close (9)        */
 139          0xCF,// 0b11001111,
 140          //      /*      Stop + Reg. (10)        */
 141          0xDB,// 0b11011011,
 142          //      /*      Close + Reg. (11)       */
 143          0xEB,// 0b11101011,
 144          //      /*      Close + Vent. (12)      */
 145          0xE7,// 0b11100111,
 146          //      /*      Vent. + Reg. (13)       */
 147          0xF3,// 0b11110011,
 148          //      /*      Auto Tx start (14)      */
 149          0xFD,// 0b11111101,
 150          //      /*      Auto Tx stop (15)       */
 151          0xFE,// 0b11111110,
 152          //      /*      No push (16)    */
 153          0xFF,// 0b11111111,
 154          } ;
 155          
 156          //
 157          void    _KeyInTx( void )
 158          {
 159   1              idata uchar     i ;
 160   1              
 161   1              m_KindOfKey = d_Idle ;
 162   1              
 163   1              m_KeyNew = 0xFF ;
 164   1              if(BAT_out==2)return;
 165   1                      
 166   1              /*      Registration sw         */
 167   1              _SwIn( PIN_KEY_OPEN ) ;
 168   1              /*      Auto Tx Start sw                */
 169   1              _SwIn( PIN_KEY_STOP ) ;
 170   1              /*      Auto Tx Stop sw         */
 171   1              _SwIn( PIN_KEY_CLOSE ) ;
 172   1              /*      Auto Tx Vent. sw                */
 173   1              _SwIn( PIN_KEY_VENT ) ; 
 174   1              //_SwIn( 1 ) ;
 175   1              /*      Auto Tx Reg. sw         */
 176   1              _SwIn( PIN_KEY_LOGIN ) ;        
 177   1              /*      Auto Tx Auto Tx Start sw                */
 178   1              _SwIn( 1 ) ;    
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 4   

 179   1              /*      Auto TxAuto Tx Stop sw          */
 180   1              _SwIn( 1 ) ;    
 181   1              
 182   1              
 183   1              if      ( m_KeyNew != m_KeyOld )                                // Key in
 184   1              {                                                                                               // Different with the last state
 185   2                      m_KeyOld = m_KeyNew ;
 186   2                      _SetKeyChatterCount() ;                                         // Chatter counter set
 187   2                      _ClearSpecialMultiKeyState() ;                          // Clear key continue state
 188   2                      TIME_Once_twice_switch=5000;   //2015.1.31修正4
 189   2                      TIME_10s=10100;  //2015.1.31修正3
 190   2                      return ;
 191   2              }
 192   1              
 193   1              if      ( --m_ChatterCount )                                            // Chattering ok ?
 194   1              {
 195   2                      return ;
 196   2              }
 197   1              m_ChatterCount = 1 ;
 198   1              
 199   1              /*              For generate Batt. Low tone             */
 200   1              if      ( m_KeyNew != d_KeyNoPush )                     // Is key data no push ?
 201   1              {                                                                                               // No, any key push
 202   2      //              if      ( m_BattState )                                                 // Batt. Low ?
 203   2      //              {                                                                                       // Yes
 204   2      //                      _ReqBuzzer(d_BuzBattLow) ;                              // Request
 205   2      //              }
 206   2                  //if(BAT_value>1000){
 207   2                 if(TIME_Once_twice_switch)--TIME_Once_twice_switch;    //2015.1.31修正4
 208   2                 if(TIME_10s)--TIME_10s;    //2015.1.31修正3
 209   2                 //dd_set_ADF7021_Power_on_Init();
 210   2              //dd_set_ML7345D_Power_on_Init();
 211   2                 if((BAT_out==1)||(FG_BAT)||(TIME_10s==0)){   //2015.1.31修正3
 212   3                    if(FG_BAT==0){
 213   4                              FG_BAT=1;
 214   4                              if(TIME_10s==0){      //2015.1.31修正3
 215   5                                 BASE_TIME_BEEP_on=103;
 216   5                                 BASE_TIME_BEEP_off=103;
 217   5                              }
 218   4                              else {
 219   5                                 BASE_TIME_BEEP_on=40;
 220   5                                 BASE_TIME_BEEP_off=60;
 221   5                              }
 222   4                              TIME_BEEP_on=BASE_TIME_BEEP_on;
 223   4                              TIME_BEEP_off=BASE_TIME_BEEP_off;
 224   4                              TIME_BEEP_freq=2;       
 225   4                    }
 226   3                    else if(TIME_BEEP_freq<=1)TIME_BEEP_freq=2;
 227   3                  }
 228   2              }
 229   1                      
 230   1              /*              Search of valid key             */
 231   1              for     ( i=0; i<17;i++)
 232   1              {
 233   2                      if      ( m_KeyNew == ct_KeyDataTable[i] )      // Match ?
 234   2                      {
 235   3                              m_KeyNo = i ;
 236   3                              break ;                                                                 // Yes
 237   3                      }
 238   2              }
 239   1              key_Value=i;   // 2015.1.31修正3
 240   1              if(FG_10s==1)return;   // 2015.1.31修正3
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 5   

 241   1              
 242   1              if      ( i == 17)                      // Found ?
 243   1              {                                                                                               // No
 244   2                      mb_NoPush = d_Clear ;                                           // No push clear(Push on)
 245   2                      _ClearSpecialMultiKeyState() ;                          // Special multi key status clear
 246   2                      mb_NoPushWait = d_On ;                                          // Set no push wait
 247   2                      _DupliFuncClear() ;                                                     // Duplicate key function clear
 248   2                      return ;
 249   2              }
 250   1              
 251   1              if      ( mb_NoPushWait )                                                       // Wait for no push ?
 252   1              {                                                                                               // Yes
 253   2                      if      ( m_KeyNew != d_KeyNoPush )             // Is key data no push ?
 254   2                      {
 255   3                              if(((i==5)||(i==6)||(i==7)||(i==9)||(i==12))&&(FLAG_APP_TX==0));    //解决复数输出
             -，按键未松一直发送 
 256   3                              else return ;                                                           // No
 257   3                      }
 258   2              }
 259   1              
 260   1              switch  ( i )    // Jumo to key function
 261   1              {
 262   2                      case 0 :
 263   2                              _FuncReg();
 264   2                              break ;         
 265   2                      case 1 :
 266   2                      case 2 :  
 267   2                      case 3 : 
 268   2                      case 4 :   
 269   2                              if(FLAG_APP_TX==0)_FuncStop();   //2015.1.31修正4
 270   2                              break ; 
 271   2                      case 5 :  
 272   2                      case 6 :  
 273   2                      case 7 :  
 274   2                      case 9 :  
 275   2                      case 12 :  
 276   2                              _FuncOpenStop();
 277   2                              break ;         
 278   2                      case 8 :  
 279   2                              _FuncOpenReg();
 280   2                              break ;
 281   2                      case 10 :  
 282   2                              _FuncStopReg();
 283   2                              break ;
 284   2                      case 11 :  
 285   2                              _FuncCloseReg();
 286   2                              break ;
 287   2                      case 13 :  
 288   2                              _FuncVentReg();
 289   2                              break ;
 290   2                      case 14 :  
 291   2                              _FuncAutoTxStart();
 292   2                              break ;
 293   2                      case 15 :  
 294   2                              _FuncAutoTxStop();
 295   2                              break ;
 296   2                      case 16 :  
 297   2                              _FuncNoPush();
 298   2                              break ;
 299   2              }
 300   1      }
 301          /*----------------------------------*/
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 6   

 302          /*                                                                      */
 303          /*              Open + Stop(5) function         */
 304          /*              Open + Close(6) function        */
 305          /*              Open + Vent.(7) function        */
 306          /*              Stop + Close(9) function        */
 307          /*              Close + Vent.(12) function      */
 308          /*                                                                      */
 309          /*----------------------------------*/
 310          //
 311          void    _FuncOpenStop( void )
 312          {
 313   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 314   1              m_KindOfKey = d_Idle ;
 315   1              _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 316   1              _ClearSpecialMultiKeyState() ;                                  // Special multi key status clear
 317   1              mb_NoPush = d_Clear ;
 318   1              mb_NoPushWait = d_On ;
 319   1      }
 320          /*----------------------------------*/
 321          /*                                                                      */
 322          /*              Open + Reg. function            */
 323          /*                                                                      */
 324          /*----------------------------------*/
 325          //
 326          void    _FuncOpenReg( void )
 327          {
 328   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 329   1              mb_NoPush = d_Clear ;
 330   1              if      ( !mb_RegOpenSw )                                                       // Continue push ?
 331   1              {                                                                                               // No
 332   2                      mb_RegOpenSw = d_On ;
 333   2                      m_TimerKey = d_Time3s ; // Set 3sec key timer
 334   2                      if(FG_PWRON==0){
 335   3                         FG_PWRON=1;
 336   3                         PIN_POWER_CONTROL=1;
 337   3                         TB_5s=TB_60s;//60;  //5.1秒
 338   3                      }
 339   2                      return ;
 340   2              }
 341   1              
 342   1              _Pass3secKey( d_ReqOpenReg ) ;
 343   1      }
 344          /*----------------------------------*/
 345          /*                                                                      */
 346          /*              Close + Reg. function           */
 347          /*                                                                      */
 348          /*----------------------------------*/
 349          //
 350          void    _FuncCloseReg( void )
 351          {
 352   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 353   1              if      ( !mb_RegCloseSw )                                                      // Continue push ?
 354   1              {                                                                                               // No
 355   2                      mb_RegCloseSw = d_On ;
 356   2                      m_TimerKey = d_Time3s ;                                         // Set 3sec key timer
 357   2                      if(FG_PWRON==0){
 358   3                         FG_PWRON=1;
 359   3                         PIN_POWER_CONTROL=1;
 360   3                         TB_5s=TB_60s;//60;  //5.1秒
 361   3                      }
 362   2                      return ;
 363   2              }
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 7   

 364   1              
 365   1              _Pass3secKey( d_ReqCloseReg ) ;
 366   1      }
 367          /*----------------------------------*/
 368          /*                                                                      */
 369          /*              Vent. + Reg. function           */
 370          /*                                                                      */
 371          /*----------------------------------*/
 372          //
 373          void    _FuncVentReg( void )
 374          {
 375   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 376   1              if      ( !mb_RegVentSw )                                                       // Continue push ?
 377   1              {                                                                                               // No
 378   2                      mb_RegVentSw = d_On ;
 379   2                      m_TimerKey = d_Time3s ;                                         // Set 3sec key timer
 380   2                      if(FG_PWRON==0){
 381   3                         FG_PWRON=1;
 382   3                         PIN_POWER_CONTROL=1;
 383   3                         TB_5s=TB_60s;//60;  //5.1秒
 384   3                      }
 385   2                      return ;
 386   2              }
 387   1              
 388   1              _Pass3secKey( d_ReqVentReg ) ;
 389   1      }
 390          /*----------------------------------*/
 391          /*                                                                      */
 392          /*              Stop + Reg. function            */
 393          /*                                                                      */
 394          /*----------------------------------*/
 395          //
 396          void    _FuncStopReg( void )
 397          {
 398   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 399   1              if      ( !mb_RegStopSw )                                                       // Continue push ?
 400   1              {                                                                                               // No
 401   2                      mb_RegStopSw = d_On ;
 402   2                      m_TimerKey = d_Time3s ;                                         // Set 3sec key timer
 403   2                      if(FG_PWRON==0){
 404   3                         FG_PWRON=1;
 405   3                         PIN_POWER_CONTROL=1;
 406   3                         TB_5s=TB_60s;//60;  //5.1秒
 407   3                      }
 408   2                      return ;
 409   2              }
 410   1              
 411   1              _Pass3secKey( d_ReqStopReg ) ;
 412   1      }
 413          void    _Pass3secKey( uchar req )
 414          {
 415   1              if      ( m_TimerKey )                                                          // 3sec passed ?
 416   1              {
 417   2                      if      ( !--m_TimerKey )
 418   2                      {                                                                                       // Yes
 419   3                              _ReqTxdEdit( req,0 ) ;
 420   3                              FG_Complex_Single_shot=1;   //2015.1.31修正2
 421   3                              return ;
 422   3                      }
 423   2              }
 424   1      }
 425          /*------------------------------------------*/
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 8   

 426          /*                                                                                      */
 427          /*              Open/Stop/Close/Vent. function          */
 428          /*                                                                                      */
 429          /*------------------------------------------*/
 430          void    _FuncReg( void )
 431          {
 432   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 433   1              if      ( mb_NoPush )                                                           // No push before ?
 434   1              {                                                                                               // Yes
 435   2                      mb_NoPush = d_Clear ;
 436   2                      m_KindOfKey = d_RegKey ;
 437   2                      _ClearSpecialMultiKeyState() ;                          // Special multi key status clear
 438   2                      mb_RegSw = d_On ;
 439   2                      m_TimerKey = d_Time3s ;                                         // Set 3sec key timer
 440   2                      if      ( !m_TimerKeyMonitor )                                  // 1st entry ?
 441   2                      {       // Yes
 442   3                                if(FG_PWRON==0){
 443   4                                   FG_PWRON=1;
 444   4                                   PIN_POWER_CONTROL=1;
 445   4                                   TB_5s=51;//TB_51s;//51;  //5.1秒
 446   4                                }     
 447   3                              m_TimerKeyMonitor = d_Time10s ;                 // Set 10sec key timer
 448   3                              m_KeyCount = 2 ;
 449   3                              return ;
 450   3                      }
 451   2                      if      ( !--m_KeyCount )                                               // ID registration mode ?
 452   2                      {
 453   3                              _SetRegistrationMode( d_RegAppend ) ;
 454   3                              m_KindOfKey = d_Idle ;
 455   3                              mb_NoPushWait = d_On ;                                  // Set no push wait
 456   3                      }
 457   2                      return ;
 458   2              }
 459   1              
 460   1              /*              Reg.sw push             */
 461   1              if      ( mb_RegSw )                                                            // Continue push ?
 462   1              {                                                                                               // Yes
 463   2                      if      ( m_TimerKey )                                                  // 3sec passed ?
 464   2                      {
 465   3                              if      ( !--m_TimerKey )
 466   3                              {                                                                               // Yes
 467   4                                      _SetRegistrationMode( d_RegDelete ) ;   // ID delete mode set
 468   4                                      m_KindOfKey = d_Idle ;
 469   4                                      mb_NoPushWait = d_On ;                          // Set no push wait
 470   4                              }
 471   3                              return ;                                                                // No
 472   3                      }
 473   2              }  
 474   1      }
 475          void    _FuncStop( void )
 476          {
 477   1              if      ( _GetNoPushState() )                                           // No push before ?
 478   1              {                                                                                               // No
 479   2                      if      ( mb_OpenSw || mb_StopSw || mb_CloseSw )// Continue push ?
 480   2                      {                                                                                       // Yes
 481   3                              if      (( !m_TimerKey )&&(FG_BAT==0)&&(TIME_Once_twice_switch==0))  //2015.1.31修正4     // 5sec passed ?
 482   3                              {
 483   4      //                              if      ( !--m_TimerKey )
 484   4      //                              {                                                                       // Yes
 485   4                                              if      ( mb_OpenSw || mb_CloseSw )                             // Close sw ?
 486   4                                              {
 487   5                                                      m_KeyOptSetMode = 10 ;                          // Yes
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 9   

 488   5                                                      //_ReqBuzzer( d_BuzOpt5 ) ;
 489   5                                                      //_ReqBuzzer(103,103,100);
 490   5                                                      m_KindOfKey = d_Idle ;
 491   5                                                      mb_NoPushWait = d_On ;                  // Set no push wait
 492   5                                                      return ;
 493   5                                              }
 494   4                                              m_KeyOptSetMode = 1 ;                   // Opetion setting mode
 495   4                                              //_ReqBuzzer( d_BuzOpt1 ) ;
 496   4                                              _ReqBuzzer(103,103,1);
 497   4                                                      FG_LED_on=1;
 498   4                                                      if(FG_PWRON==0){
 499   5                                                          FG_PWRON=1;
 500   5                                                          PIN_POWER_CONTROL=1;
 501   5                                                          TB_5s=TB_51s;//51;  //5.1秒
 502   5                                                      }
 503   4                                              m_KeyDupliSetTimeout = d_DupliTime4s ;
 504   4                                              m_KindOfKey = d_Idle ;
 505   4                                              mb_NoPush=d_Off;
 506   4                                              mb_NoPushWait = d_On ;                  // Set no push wait
 507   4                                              m_KeyOptSetOpenStop = 1 ;
 508   4                                              if      ( mb_OpenSw )                           // Open ?
 509   4                                              {
 510   5                                                      m_KeyOptSetOpenStop = 0 ;       // Yes
 511   5                                              }
 512   4      //                              }
 513   4      //                              return ;                                                        // No
 514   4                              }
 515   3                              return ;
 516   3                      }
 517   2                      return ;
 518   2              }
 519   1              
 520   1              m_KindOfKey = m_KeyNo ;
 521   1              if      ( m_KeyOptSetMode ||m_RegMode)                                                  // Option setting mode ?
 522   1              {
 523   2                      return ;                                                                        // Yes
 524   2              }
 525   1              
 526   1              switch  ( m_KindOfKey )
 527   1              {
 528   2                      case d_OpenKey :
 529   2                              mb_OpenSw = d_On ;
 530   2                              m_TimerKey = d_Time5s ;                                 // Set 5sec key timer
 531   2                              break;
 532   2                              
 533   2                      case d_StopKey :
 534   2                              mb_StopSw = d_On ;
 535   2                              m_TimerKey = d_Time5s ;                                 // Set 5sec key timer
 536   2                              break;
 537   2                              
 538   2                      case d_CloseKey :
 539   2                              mb_CloseSw = d_On ;
 540   2                              m_TimerKey = d_Time5s ;//d_Time9s ;                                     // Set 5sec key timer
 541   2                              break;
 542   2              }
 543   1              
 544   1                /********2015.1.31追加  按一次模式********/
 545   1              if      ( !rom_KeyOpt || m_KindOfKey == d_VentKey  )// Single push option or Vent. key ?
 546   1              
 547   1      //          /********2015.1.31追加  按2次模式********/
 548   1      //      if      ( rom_KeyOpt || m_KindOfKey == d_VentKey  )// Single push option or Vent. key ?        
 549   1              {                                                                                               // Yes
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 10  

 550   2                      _DupliFuncClear() ;                                                     // Duplicate key function clear
 551   2                      _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 552   2                      m_TimerKeyMonitor = d_Clear ;
 553   2                      return ;
 554   2              }
 555   1              
 556   1              /*      Multi push option       */
 557   1              if      ( m_KeyOptSetMode || m_RegMode )
 558   1              {
 559   2                      return ;
 560   2              }
 561   1              
 562   1              if      ( m_KindOfKey == d_StopKey )
 563   1              {
 564   2                      _DupliFuncClear() ;                                                     // Duplicate key function clear
 565   2                      _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 566   2                      m_TimerKeyMonitor = d_Clear ;
 567   2                      FG_d_StopKey=1;
 568   2                      m_KeyDupli1stTimer = d_D1stTime3s ;
 569   2                      time_led=0;
 570   2                      return ;
 571   2              }
 572   1              
 573   1              switch  ( m_KindOfKey )
 574   1              {
 575   2      //              case d_OpenKey :
 576   2      //                      m_KeyCloseCount = 2 ;
 577   2      //                      if      ( !--m_KeyOpenCount )
 578   2      //                      {
 579   2      //                              _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 580   2      //                              m_TimerKeyMonitor = d_Clear ;
 581   2      //                              _DupliFuncClear() ;                                     // Duplicate key function clear
 582   2      //                              return ;
 583   2      //                      }
 584   2      //                      m_KeyDupli1stTimer = d_D1stTime3s ;
 585   2      //                      break;
 586   2      //                      
 587   2      //              case d_CloseKey :
 588   2      //                      m_KeyOpenCount = 2 ;
 589   2      //                      if      ( !--m_KeyCloseCount )
 590   2      //                      {
 591   2      //                              _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 592   2      //                              m_TimerKeyMonitor = d_Clear ;
 593   2      //                              _DupliFuncClear() ;                                     // Duplicate key function clear
 594   2      //                              return ;
 595   2      //                      }
 596   2      //                      m_KeyDupli1stTimer = d_D1stTime3s ;
 597   2      //                      break;
 598   2                
 599   2                      case d_OpenKey :
 600   2                      case d_CloseKey :  
 601   2                              if      ( FG_d_StopKey && m_KeyDupli1stTimer)
 602   2                              {
 603   3                                      FG_d_StopKey=0;
 604   3                                      m_KeyDupli1stTimer=0;
 605   3                                      _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 606   3                                      m_TimerKeyMonitor = d_Clear ;
 607   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 608   3                                      return ;
 609   3                              }
 610   2                              break;
 611   2                                              
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 11  

 612   2              }  
 613   1      }
 614          
 615          void    _FuncAutoTxStart( void )
 616          {
 617   1        
 618   1      }
 619          void    _FuncAutoTxStop( void )
 620          {
 621   1        
 622   1      }
 623          void    _FuncNoPush( void )
 624          {
 625   1              mb_OpenSw = d_Off ;                                                     // For duplicate keyvfunction
 626   1              mb_StopSw = d_Off ;
 627   1              mb_CloseSw = d_Off ;
 628   1              FG_BAT=0;
 629   1              
 630   1              _ClearSpecialMultiKeyState() ;                          // Special multi key status clear
 631   1              mb_NoPush     = d_On ;                                          // No push on
 632   1              mb_NoPushWait = d_Off ;                                         // No push wait clear
 633   1              m_KindOfKey = d_KeyNoPush;//d_NoPushKey ;
 634   1      //      if      ( m_BuzzerMode == d_BuzBattLow )                        // Batt.Low sound out ?
 635   1      //      {
 636   1      //              _BuzIdle() ;
 637   1      //      }  
 638   1      }
 639          void    _SetKeyChatterCount( void )
 640          {
 641   1              m_ChatterCount = d_Time50ms ;                                           // Chatter counter set
 642   1              m_TimerKey = 0 ;
 643   1      }
 644          /*==============================================*/
 645          /*                                                                                              */
 646          /*              Clear special multi key push status             */
 647          /*                                                                                              */
 648          /*                       in  : none                                                     */
 649          /*                       out : none                                                     */
 650          /*                                                                                              */
 651          /*==============================================*/
 652          //
 653          void    _ClearSpecialMultiKeyState( void )
 654          {
 655   1              mb_RegSw      = d_Clear ;
 656   1              mb_RegStopSw  = d_Clear ;
 657   1              mb_RegOpenSw  = d_Clear ;
 658   1              mb_RegCloseSw = d_Clear ;
 659   1              mb_RegVentSw  = d_Clear ;
 660   1      }
 661          /****************************************/
 662          /*                                                                              */
 663          /*              Key duplicate function clear    */
 664          /*                                                                              */
 665          /*                        in  : none                            */
 666          /*                        out : none                            */
 667          /*                                                                              */
 668          /****************************************/
 669          //
 670          void    _DupliFuncClear( void )
 671          {
 672   1              m_KeyOptSetMode = d_Idle ;
 673   1              m_KeyOpenCount = 2 ;
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 12  

 674   1              m_KeyCloseCount = 2 ;
 675   1              //mb_OpenSw = d_Off ;
 676   1              //mb_StopSw = d_Off ;
 677   1              if      ( m_KeyDupli1stTimer )
 678   1              {
 679   2                      m_KeyDupli1stTimer = d_Clear ;
 680   2                      //_LedOnOff( d_LedOff ) ;                               // Led off
 681   2              }
 682   1      }
 683          /*==============================================*/
 684          /*                                                                                              */
 685          /*                      No Push(Last time) check                        */
 686          /*                                                                                              */
 687          /*                       in  : none                                                     */
 688          /*                       out : 0: No push                                       */
 689          /*                                 1: any push                                  */
 690          /*                                                                                              */
 691          /*==============================================*/
 692          //
 693          u8 _GetNoPushState(void)
 694          {
 695   1              if      (!mb_NoPush)                                                            // No push before ?
 696   1              {                                                                                               // No
 697   2                      return(d_NG) ;
 698   2              }
 699   1              
 700   1              mb_NoPush = d_Clear ;
 701   1      //      /*              Set Auto Tx inhibit             */
 702   1      //      mb_AutoTxInhibit = d_On ;                               // Inhibit
 703   1      //      mb_AutoTxOnOff   = d_Off ;                              // Off
 704   1      //      
 705   1              m_TimerKey = d_Clear ;
 706   1              _ClearSpecialMultiKeyState() ;                                  // Special multi key status clear
 707   1              return(d_OK) ;
 708   1      }
 709          
 710          void _ReqTxdEdit(u8 txreq ,u8 buzreq )  // Tx data edit request
 711          {
 712   1          u8 time_key;
 713   1          if((TB_sum_5s<69)&&(FG_PWRON==1)&&(TB_5s<25))
 714   1          {      //计算剩余的时间，总共时间不能超过69，以25为间隔。
 715   2              time_key=25-TB_5s;
 716   2              TB_sum_5s=TB_sum_5s+time_key;
 717   2              if((69-TB_sum_5s)>=27)  TB_5s=25;
 718   2          }
 719   1          if((TB_5s>=25)||(TIME_2s_RestTX==0))
 720   1          {   //2015.4.13修正
 721   2              if(FG_PWRON==0)
 722   2              {
 723   3                  FG_PWRON=1;
 724   3                  PIN_POWER_CONTROL=1;
 725   3                  TB_5s=TB_51s;//51;  //5.1秒
 726   3              }
 727   2              switch  ( txreq )    // Jumo to key function
 728   2              {
 729   3                  case 1 :
 730   3                          Control_code=0x08;     //open
 731   3                      break ;
 732   3                  case 2 :    
 733   3                          Control_code=0x04;    //stop
 734   3                      break ;
 735   3                  case 3 :    
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 13  

 736   3                          Control_code=0x02;    //close
 737   3                      break ;
 738   3                  case 4 :    
 739   3                          Control_code=0x01;    //vnet 换气
 740   3                      break ;
 741   3                  case 5 :                      //Open + Stop    
 742   3                          Control_code=0x0C;
 743   3                          break ;     
 744   3                  case 6 :                   //Open + Close
 745   3                         Control_code=0x0A;
 746   3                          break ;     
 747   3                  case 7 :                   //Open + Vent
 748   3                         Control_code=0x09;
 749   3                          break ;     
 750   3                  case 8:                     //Open + Reg
 751   3                          Control_code=0x18;
 752   3                          break;
 753   3                  case 9 :                //Stop + Close
 754   3                         Control_code=0x06;
 755   3                          break ;     
 756   3                  case 10 :                 //Stop + Reg
 757   3                          Control_code=0x14;
 758   3                          break ;
 759   3                  case 11 :                 //Close + Reg
 760   3                          Control_code=0x12;
 761   3                          break ;
 762   3                  case 12 :              //Close + Vent.
 763   3                         Control_code=0x03;
 764   3                          break ;     
 765   3              }
 766   2              switch  ( buzreq )    // Jumo to key function
 767   2              {
 768   3                  case 1 :
 769   3                         _ReqBuzzer(103,103,0);
 770   3          //                  BASE_TIME_BEEP_on=103;
 771   3          //                        BASE_TIME_BEEP_off=103;
 772   3          //                  TIME_BEEP_freq=0;
 773   3                      break ;
 774   3                  case 2 :
 775   3                         _ReqBuzzer(103,103,1);
 776   3          //                  BASE_TIME_BEEP_on=103;
 777   3          //                        BASE_TIME_BEEP_off=103;
 778   3          //                  TIME_BEEP_freq=1;
 779   3                      break ;
 780   3                  case 3 :    
 781   3                        _ReqBuzzer(103,103,2);
 782   3          //                  BASE_TIME_BEEP_on=103;
 783   3          //                        BASE_TIME_BEEP_off=103;
 784   3          //                  TIME_BEEP_freq=2;
 785   3                      break ;
 786   3                  case 4 :    
 787   3                        _ReqBuzzer(500,10,0);
 788   3                        break ;
 789   3                  case 20 :   
 790   3                         _ReqBuzzer(1000,10,0);
 791   3          //                  BASE_TIME_BEEP_on=1000;
 792   3          //                        BASE_TIME_BEEP_off=1;
 793   3          //                  TIME_BEEP_freq=0;
 794   3                      break ;
 795   3              }       
 796   2              dd_set_ML7345D_Power_on();
 797   2              PROFILE_CH_FREQ_32bit_200002EC = 426075000;
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 14  

 798   2              RF_ML7345_Init(Fre_426_075,0x15,12);    
 799   2              SendTxData();
 800   2              TIME_2s_RestTX = 25;       //2015.4.13修正        
 801   2        }
 802   1        else PIN_LED=0;
 803   1      }
 804          
 805          //
 806          /************************************************/
 807          /*                                                                                              */
 808          /*              Key duplicate function setting mode             */
 809          /*                              Every 10ms                                              */
 810          /*                                                                                              */
 811          /*                        in  : none                                            */
 812          /*                        out : none                                            */
 813          /*                                                                                              */
 814          /************************************************/
 815          //
 816          void    _DupliFuncSetMode( void )
 817          {
 818   1        u8 m_KeyOpt;
 819   1              switch  ( m_KeyOptSetMode )
 820   1              {
 821   2                      case 1 :
 822   2                              if      ( !mb_NoPushWait )                                      // No push ?
 823   2                              {
 824   3                                      m_KeyDupliSetTimeout = d_DupliTime1s ;  // Yes
 825   3                                      ++m_KeyOptSetMode ;
 826   3                                      return ;
 827   3                              }
 828   2                              if      ( !m_KeyDupliSetTimeout )                       // Pushing 9s over ?
 829   2                              {
 830   3                                      m_KeyOptSetMode = 10 ;                          // Yes
 831   3                                      //_ReqBuzzer( d_BuzOpt5 ) ;
 832   3                                      //_ReqBuzzer(103,103,100);
 833   3                                      
 834   3                              }
 835   2                              break ;
 836   2                              
 837   2                      case 2 :
 838   2                              if      ( !m_KeyDupliSetTimeout )                       // Wait 1s ok ?
 839   2                              {                                                                               // Yes
 840   3                                      ++m_KeyOptSetMode;
 841   3                                      m_KeyDupliSetTimeout = d_DupliTime3s ;
 842   3                                      //_ReqBuzzer( d_BuzOpt2 ) ;
 843   3                                      _ReqBuzzer(103,103,0);
 844   3                                      FG_LED_on=1;
 845   3                              }
 846   2                              
 847   2                              if      ( m_KindOfKey != d_Idle && m_KindOfKey != d_KeyNoPush )
 848   2                              {
 849   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 850   3                              }
 851   2                              break ;
 852   2                              
 853   2                      case 3 :                                                                        // Sw in wait
 854   2                              if      ( !m_KeyDupliSetTimeout )
 855   2                              {
 856   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 857   3                                      return ;
 858   3                              }
 859   2                              
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 15  

 860   2                              if      ( m_KindOfKey == d_Idle || m_KindOfKey == d_KeyNoPush )
 861   2                              {
 862   3                                      return ;
 863   3                              }
 864   2                              
 865   2                              if      ( m_KeyOptSetOpenStop )                         // Setting by stop ?
 866   2                              {                                                                               // Yes
 867   3                                      if      ( m_KindOfKey == d_StopKey )
 868   3                                      {
 869   4                                              m_KeyDupliSetTimeout = d_DupliTime1s ;
 870   4                                              ++m_KeyOptSetMode ;
 871   4                                              //mb_NoPushWait = d_On ;
 872   4                                      }
 873   3                                      else
 874   3                                      {                                                                       // Error
 875   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 876   4                                              return ;
 877   4                                      }
 878   3                              }
 879   2                              else
 880   2                              {
 881   3                                      if      ( m_KindOfKey == d_OpenKey )
 882   3                                      {
 883   4                                              m_KeyDupliSetTimeout = d_DupliTime1s ;
 884   4                                              ++m_KeyOptSetMode ;
 885   4                                              
 886   4                                      }
 887   3                                      else
 888   3                                      {                                                                       // Error
 889   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 890   4                                              return ;
 891   4                                      }
 892   3                              }
 893   2                              break ;
 894   2                              
 895   2                      case 4 :
 896   2                              if      ( !m_KeyDupliSetTimeout )                       // Wait 1s ok ?
 897   2                              {                                                                               // Yes
 898   3                                      ++m_KeyOptSetMode ;
 899   3                                      m_KeyDupliSetTimeout = d_DupliTime3s ;
 900   3                                      //_ReqBuzzer( d_BuzOpt2 ) ;
 901   3                                      _ReqBuzzer(103,103,0);
 902   3                                      FG_LED_on=1;
 903   3                              }
 904   2      //                      
 905   2      //                      if      ( m_KindOfKey != d_Idle && m_KindOfKey != d_KeyNoPush  )
 906   2      //                      {                                                                               // Error
 907   2      //                              _DupliFuncClear() ;                                     // Duplicate key function clear
 908   2      //                      }
 909   2                              break ;
 910   2                              
 911   2                      case 5 :                                                                        // Sw in wait
 912   2                              if      ( !m_KeyDupliSetTimeout )
 913   2                              {
 914   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 915   3                                      return ;
 916   3                              }
 917   2                              
 918   2                              if      ( m_KindOfKey == d_Idle || m_KindOfKey == d_KeyNoPush )
 919   2                              {
 920   3                                      return ;
 921   3                              }
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 16  

 922   2                              
 923   2                              if      ( m_KeyOptSetOpenStop )                         // Setting by stop ?
 924   2                              {                                                                               // Yes
 925   3                                      if      ( m_KindOfKey == d_StopKey )
 926   3                                      {
 927   4                                              m_KeyDupliSetTimeout = d_DupliTime1s ;
 928   4                                              ++m_KeyOptSetMode ;
 929   4                                              mb_NoPushWait = d_On ;
 930   4                                      }
 931   3                                      else
 932   3                                      {                                                                       // Error
 933   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 934   4                                              return ;
 935   4                                      }
 936   3                              }
 937   2                              else
 938   2                              {
 939   3                                      if      ( m_KindOfKey == d_OpenKey )
 940   3                                      {
 941   4                                              m_KeyDupliSetTimeout = d_DupliTime1s ;
 942   4                                              ++m_KeyOptSetMode ;
 943   4                                      }
 944   3                                      else
 945   3                                      {                                                                       // Error
 946   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 947   4                                              return ;
 948   4                                      }
 949   3                              }
 950   2                              break ;
 951   2                              
 952   2                      case 6 :
 953   2                              if      ( !m_KeyDupliSetTimeout )                       // Wait 1s ok ?
 954   2                              {                                                                               // Yes
 955   3                                      ++m_KeyOptSetMode ;
 956   3                                      m_KeyDupliSetTimeout = d_DupliTime3s ;
 957   3                                      //_ReqBuzzer( d_BuzOpt3 ) ;
 958   3                                      _ReqBuzzer(103,103,2);
 959   3                                      FG_LED_on=1;                            
 960   3                              }
 961   2                              
 962   2      //                      if      ( m_KindOfKey != d_Idle && m_KindOfKey != d_KeyNoPush )
 963   2      //                      {                                                                               // Error
 964   2      //                              _DupliFuncClear() ;                                     // Duplicate key function clear
 965   2      //                      }
 966   2                              break ;
 967   2                              
 968   2                      case 7 :                                                                        // Sw in wait
 969   2                              if      ( !m_KeyDupliSetTimeout )
 970   2                              {
 971   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 972   3                                      return ;
 973   3                              }
 974   2                              
 975   2                              if      ( m_KindOfKey == d_Idle || m_KindOfKey == d_KeyNoPush )
 976   2                              {
 977   3                                      return ;
 978   3                              }
 979   2                              
 980   2                              if      ( m_KeyOptSetOpenStop )                         // Setting by stop ?
 981   2                              {                                                                               // Yes
 982   3                                      if      ( m_KindOfKey == d_StopKey )
 983   3                                      {
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 17  

 984   4                                              m_KeyDupliSetTimeout = d_DupliTime10s ;
 985   4                                              ++m_KeyOptSetMode ;
 986   4                                              mb_NoPushWait = d_On ;
 987   4                                      }
 988   3                                      else
 989   3                                      {                                                                       // Error
 990   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 991   4                                              return ;
 992   4                                      }
 993   3                              }
 994   2                              else
 995   2                              {
 996   3                                      if      ( m_KindOfKey == d_OpenKey )
 997   3                                      {
 998   4                                              m_KeyDupliSetTimeout = d_DupliTime10s ;
 999   4                                              ++m_KeyOptSetMode ;
1000   4                                      }
1001   3                                      else
1002   3                                      {                                                                       // Error
1003   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
1004   4                                              return ;
1005   4                                      }
1006   3                              }
1007   2                              break ;
1008   2                              
1009   2                      case 8 :                                                                        // Sw in wait
1010   2                      case 9 :                                                                        // Sw in wait
1011   2                              if      ( !m_KeyDupliSetTimeout )
1012   2                              {
1013   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
1014   3                                      return ;
1015   3                              }
1016   2                              
1017   2                              if      ( m_KindOfKey == d_Idle || m_KindOfKey == d_KeyNoPush )
1018   2                              {
1019   3                                      return ;
1020   3                              }
1021   2                              
1022   2                              if      ( m_KeyOptSetOpenStop )                         // Setting by stop ?
1023   2                              {                                                                               // Yes
1024   3                                      if      ( m_KindOfKey == d_StopKey )
1025   3                                      {
1026   4                                              if      ( m_KeyOptSetMode == 9 )
1027   4                                              {
1028   5                                                      m_KeyOpt = rom_KeyOpt ;
1029   5                                                      if      ( m_KeyOpt )
1030   5                                                      {
1031   6                                                              m_KeyOpt = 0 ;
1032   6                                                      }
1033   5                                                      else
1034   5                                                      {
1035   6                                                              m_KeyOpt = 1 ;
1036   6                                                      }
1037   5                                                      rom_KeyOpt = m_KeyOpt;
1038   5                              IAP_WriteBuf_With_Protect_Verify(addr_eeprom_sys+Addr_rom_KeyOpt,&rom_KeyOpt,1);
1039   5                                                      //KeyOpt_EEPROM_write();
1040   5                                                      //_FlashWriteID() ;                             // Write data to flash rom
1041   5                                                      
1042   5                                                      //_ReqBuzzer( d_BuzOpt4 ) ;
1043   5                                                      _ReqBuzzer(103,103,4);
1044   5                                                      FG_LED_on=1;    
1045   5                                                      FG_d_StopKey=0;
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 18  

1046   5                                                      TB_5s=TB_20s;//20;
1047   5                                                      _DupliFuncClear() ;                             // Duplicate key function clear
1048   5                                                      return ;
1049   5                                              }
1050   4                                              ++m_KeyOptSetMode ;
1051   4                                      }
1052   3                                      else
1053   3                                      {                                                                       // Error
1054   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
1055   4                                              return ;
1056   4                                      }
1057   3                              }
1058   2                              else
1059   2                              {
1060   3                                      if      ( m_KindOfKey == d_OpenKey )
1061   3                                      {
1062   4                                              if      ( m_KeyOptSetMode == 9 )
1063   4                                              {
1064   5                                                      m_KeyOpt = rom_KeyOpt ;
1065   5                                                      if      ( m_KeyOpt )
1066   5                                                      {
1067   6                                                              m_KeyOpt = 0 ;
1068   6                                                      }
1069   5                                                      else
1070   5                                                      {
1071   6                                                              m_KeyOpt = 1 ;
1072   6                                                      }
1073   5                                                      rom_KeyOpt=m_KeyOpt;
1074   5                              IAP_WriteBuf_With_Protect_Verify(addr_eeprom_sys+Addr_rom_KeyOpt,&rom_KeyOpt,1);
1075   5                                                      //KeyOpt_EEPROM_write();                                // Write data to flash rom
1076   5                                                      
1077   5                                                      //_ReqBuzzer( d_BuzOpt4 ) ;
1078   5                                                      _ReqBuzzer(103,103,4);
1079   5                                                      FG_LED_on=1;
1080   5                                                      FG_d_StopKey=0;
1081   5                                                      _DupliFuncClear() ;                             // Duplicate key function clear
1082   5                                                      
1083   5                                                      return ;
1084   5                                              }
1085   4                                              ++m_KeyOptSetMode ;
1086   4                                      }
1087   3                                      else
1088   3                                      {                                                                       // Error
1089   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
1090   4                                              return ;
1091   4                                      }
1092   3                              }
1093   2                              break ;
1094   2                              
1095   2                      case 10 :
1096   2                              if      ( !mb_NoPushWait )                                      // No push ?
1097   2                              {
1098   3                                      //_BuzIdle() ;
1099   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
1100   3                                      return ;
1101   3                              }
1102   2                              break ;
1103   2                              
1104   2              }
1105   1      }
1106          /****************************************/
1107          /*                                                                              */
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 19  

1108          /*              Registration mode procedure             */
1109          /*                                                                              */
1110          /*                        in  : none                            */
1111          /*                        out : none                            */
1112          /*                                                                              */
1113          /****************************************/
1114          //
1115          void    _RegistrationMode( void )
1116          {
1117   1              if      ( !_GetRegMode() )                                                      // Reg. mode Idle ?
1118   1              {                                                                                               // Yes
1119   2                      return ;
1120   2              }
1121   1      
1122   1              if(FG_PWRON==0){
1123   2              FG_PWRON=1;
1124   2              PIN_POWER_CONTROL=1;
1125   2              }       
1126   1              if(m_TimerRegMode){
1127   2                TB_5s=51;//TB_51s;//51;  //5.1秒
1128   2                time_led++;
1129   2                if(time_led>=500){time_led=0;PIN_LED=!PIN_LED;}         
1130   2              }
1131   1              else {
1132   2                      //_ReqBuzzer(500,250,3);
1133   2                      _ReqBuzzer(500,250,2);
1134   2                      PIN_LED=0;
1135   2                      m_RegMode = d_Idle ;
1136   2              }
1137   1              /*      Led control     */
1138   1      //      if      ( mb_LedOnOff )                                                         // Led on timing ?
1139   1      //      {                                                                                               // Yes
1140   1      //              _LedOnOff( d_LedOn ) ;                                          // Led on
1141   1      //      }
1142   1      //      else
1143   1      //      {
1144   1      //              _LedOnOff( d_LedOff ) ;                                         // Led off
1145   1      //      }
1146   1              
1147   1              switch  ( m_KindOfKey )
1148   1              {
1149   2                      case    d_OpenKey :
1150   2                              if      ( ++m_RegID[m_RegDigit] > '9' )         // No. up
1151   2                              {
1152   3                                      m_RegID[m_RegDigit] = '0' ;
1153   3                              }
1154   2                              //_ReqBuzzer(d_BuzOpen) ;
1155   2                              _ReqBuzzer(103,103,0);
1156   2                              m_TimerRegMode = d_Time1min ;                   // 1min. set (1s base)
1157   2                              break ;
1158   2                              
1159   2                      case    d_StopKey :                                             // Next digit
1160   2                              if      ( ++m_RegDigit > 8 )
1161   2                              {
1162   3                                      m_RegDigit= 8 ;
1163   3                              }
1164   2      /*              Add on 2007/5/28                */
1165   2                              else
1166   2                              {
1167   3                                      //_ReqBuzzer(d_BuzStop) ;
1168   3                                _ReqBuzzer(103,103,1);
1169   3                              }
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 20  

1170   2      /*********************************/
1171   2      /*              Deleted on 2007/5/28            */
1172   2      //                      _ReqBuzzer(d_BuzStop) ;
1173   2      /*********************************/
1174   2                              m_TimerRegMode = d_Time1min ;                   // 1min. set (1s base)
1175   2                              break ;
1176   2                              
1177   2                      case    d_CloseKey :
1178   2                              _IdClear() ;                                                    // ID clear
1179   2                              //_ReqBuzzer(d_BuzReg) ;
1180   2                              _ReqBuzzer(1000,10,0);
1181   2                              m_TimerRegMode = d_Time1min ;                   // 1min. set (1s base)
1182   2                              break ;
1183   2                              
1184   2                      case    d_RegKey :                                              // Send ID
1185   2      /*              Add on 2007/5/28                */
1186   2                              if      ( m_RegDigit < 8 )
1187   2                              {
1188   3                                      return ;
1189   3                              }
1190   2      /*********************************/
1191   2      
1192   2                              //_SetRegModeIdle() ;
1193   2                              //m_RegMode = d_Idle ;
1194   2                              ID_data_add.IDC = (ulong)atol(m_RegID) ;
1195   2      /*              Modified on 2007/5/28           */
1196   2      //                      if      ( m_RFID.ID > 16777215 )                        // Over ?
1197   2                              if      ( ID_data_add.IDC > 16777214 )                  // Over ?
1198   2      /*********************************/
1199   2                              {
1200   3                                      //_ReqBuzzer(d_BuzRegEnd) ;
1201   3                                      _ReqBuzzer(100,100,3);            
1202   3                              }
1203   2                              else
1204   2                              {
1205   3                                      _ReqTxdEdit(20,20) ;
1206   3                                    
1207   3                              }
1208   2                              m_RegMode = d_Idle ;
1209   2                              break ;
1210   2              }
1211   1      }
1212          //
1213          
1214          
1215          
1216          u32 atol (unsigned char* m_RegID_x)
1217          {
1218   1        u8 i,j;
1219   1        u32 m_ID=0;
1220   1          
1221   1        for(i=0;i<8;i++){
1222   2          j=m_RegID_x[i]-'0';
1223   2          m_ID=m_ID*10+j;
1224   2        }
1225   1        return(m_ID);
1226   1      }
1227          
1228          
1229          /************************************************/
1230          /*                                                                                              */
1231          /*                              Set registration mode                   */
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 21  

1232          /*                                                                                              */
1233          /*              in  : mode( 0:Idle/1:Append/2:Delete )  */
1234          /*              out : none                                                              */
1235          /*                                                                                              */
1236          /************************************************/
1237          //
1238          void    _SetRegistrationMode( uchar mode )
1239          {
1240   1              if      (_GetRegMode())                                                 // Reg. mode Idle ?
1241   1              {                                                                                               // No
1242   2                      return ;
1243   2              }
1244   1              
1245   1              m_RegMode = mode ;
1246   1      //      m_RFAddDelCode = 0x00 ;                                         // Set delete
1247   1      //      if      ( m_RegMode == d_RegAppend )                    // Append ?
1248   1      //      {                                                                                       // Yes
1249   1      //              m_RFAddDelCode = 0xFF ;                                 // Set Append
1250   1      //      }
1251   1              
1252   1              _IdClear() ;                                                            // ID clear
1253   1              
1254   1      //      _LedOnOff( d_LedOn ) ;                                          // Led on
1255   1      //      m_BlkTimer = d_Time500ms ;                                      // Blink start
1256   1      //      mb_LedOnOff = d_On ;
1257   1      //      
1258   1      //      _ReqBuzzer(d_BuzReg) ;
1259   1              _ReqBuzzer(1000,10,0);
1260   1              m_TimerRegMode = d_Time1min ;                           // 1min. set (1s base)
1261   1      }
1262          u8 _GetRegMode(void)
1263          {
1264   1              return(m_RegMode) ;
1265   1      }
1266          /********************************************/
1267          /*                                                                                      */
1268          /*                                      ID clear                                */
1269          /*                                                                                      */
1270          /********************************************/
1271          //
1272          void _IdClear(void)
1273          {
1274   1              register        uchar   i ;
1275   1              
1276   1              m_RegDigit = 0 ;                                                        // Digit pointer clear
1277   1              //m_RFID.ID  = 0 ;                                                      // ID Number clear
1278   1              for     ( i=0; i<8; i++ )                                               // ID clear
1279   1              {
1280   2                      m_RegID[i] = '0' ;
1281   2              }
1282   1              m_RegID[8] = 0 ;                                                        // NULL set
1283   1              
1284   1      }
1285          
1286          //
1287          /*--------------------------------------*/
1288          /*                                      */
1289          /*                      Sw data input   */
1290          /*                                      */
1291          /*                        in  : sw      */
1292          /*                        out : none    */
1293          /*                                      */
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 22  

1294          /*--------------------------------------*/
1295          //
1296          void _SwIn(u8 sw)
1297          {
1298   1              m_KeyNew<<= 1 ;
1299   1              if      ( sw )
1300   1              {
1301   2                      m_KeyNew |= d_On ;
1302   2              }
1303   1      }
1304          
1305          void _ReqBuzzer(u16 BEEP_on_SET,u8 BEEP_off_SET,u8 BEEP_freq_SET)
1306          {
1307   1          if(FG_BAT==0)
1308   1          {
1309   2              BASE_TIME_BEEP_on=BEEP_on_SET;
1310   2              BASE_TIME_BEEP_off=BEEP_off_SET;
1311   2              TIME_BEEP_on=BASE_TIME_BEEP_on;
1312   2              TIME_BEEP_off=BASE_TIME_BEEP_off;
1313   2              TIME_BEEP_freq=BEEP_freq_SET;
1314   2          }
1315   1      }
1316          
1317          #if (STX0011 == 1)
              xdata u8 key_cnt = 0;
              #endif
1320          void test_mode_control(void)
1321          {
1322   1      
1323   1          while(PIN_test_mode == 0)
1324   1          { 
1325   2              if(Flag_test_mode == 0)
1326   2                      {
1327   3                              Flag_test_mode = 1;
1328   3                              PIN_POWER_CONTROL = 1;
1329   3                  PIN_TX_LED = 1;
1330   3                              Init_Uart0_T1(); 
1331   3                  INT_EnAll(); 
1332   3                  Beep_On();
1333   3                  TIME_BEEP_off = 200; 
1334   3                  Flag_beep = 0;
1335   3                      }
1336   2              if(TIME_BEEP_off == 0 && Flag_beep == 0) 
1337   2              { 
1338   3                  Flag_beep = 1;           
1339   3                  Beep_Off();
1340   3              }
1341   2              ClearWDT(); // Service the WDT 
1342   2              if((PIN_KEY_OPEN==0)&&(FG_KEY_OPEN==0))
1343   2              {
1344   3                  FG_KEY_OPEN = 1;
1345   3                  dd_set_ML7345D_Power_on();
1346   3                  PROFILE_CH_FREQ_32bit_200002EC = 426075000;
1347   3                  RF_ML7345_Init(Fre_426_075,0x15,12);
1348   3                  FG_test_mode = 0;
1349   3                  Tx_Data_Test(0);
1350   3              }
1351   2              if(PIN_KEY_OPEN == 1) FG_KEY_OPEN = 0;
1352   2      
1353   2              if((PIN_KEY_STOP == 0)&&(FG_KEY_STOP == 0))
1354   2              {
1355   3                  FG_KEY_STOP = 1;
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     06/06/2022 10:32:29 PAGE 23  

1356   3                  ML7345_RESETN = 0;
1357   3                  SpiGpio_UnInit(); 
1358   3                  ML7345D_POWER = FG_NOT_allow_out;
1359   3                  FG_test_mode = 0;
1360   3              }
1361   2              if(PIN_KEY_STOP == 1)   FG_KEY_STOP = 0; 
1362   2      #if (STX0011 == 1)
                      if(key_cnt >= 2)
                      {
                          key_cnt = 0;
                          FG_KEY_STOP = 1;
                          ML7345_RESETN = 0;
                          SpiGpio_UnInit(); 
                          ML7345D_POWER = FG_NOT_allow_out;
                          FG_test_mode = 0;
                      }
              #endif
1373   2              if((PIN_KEY_CLOSE == 0) && (FG_KEY_CLOSE == 0))
1374   2              {
1375   3                  FG_KEY_CLOSE = 1;
1376   3                  dd_set_ML7345D_Power_on();
1377   3                  PROFILE_CH_FREQ_32bit_200002EC = 426075000;
1378   3                  RF_ML7345_Init(Fre_426_075,0x15,12);
1379   3                  Tx_Data_Test(1);
1380   3                  FG_test_mode = 1;
1381   3      #if (STX0011 == 1)
                          key_cnt++;
              #endif
1384   3              }
1385   2              if(PIN_KEY_CLOSE == 1)    FG_KEY_CLOSE=0;  
1386   2      
1387   2              PC_PRG();              // PC控制  
1388   2          }  
1389   1          if(Flag_test_mode == 1)
1390   1          {
1391   2              Flag_test_mode = 0;
1392   2              UART1_end();
1393   2          }
1394   1          PIN_POWER_CONTROL = 0;
1395   1          PIN_TX_LED = 0;
1396   1          FG_KEY_OPEN = 0;
1397   1          FG_KEY_STOP = 0;
1398   1          FG_KEY_CLOSE = 0;  
1399   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5550    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     38    ----
   IDATA SIZE       =      1    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
