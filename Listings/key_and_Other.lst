C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE KEY_AND_OTHER
OBJECT MODULE PLACED IN .\Objects\key_and_Other.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE user\src\key_and_Other.c OPTIMIZE(0,SPEED) BROWSE INCDIR(.\include;.\use
                    -r\inc) DEBUG OBJECTEXTEND PRINT(.\Listings\key_and_Other.lst) OBJECT(.\Objects\key_and_Other.obj)

line level    source

   1          /***********************************************************************/
   2          /*  FILE        :key_and_Other.c                                       */
   3          /*  DATE        :Mar, 2014                                             */
   4          /*  Programmer  :xiang 'R                                              */
   5          /*  CPU TYPE    :STM8S003     Crystal: 4M HSI                          */
   6          /*  DESCRIPTION :                                                      */
   7          /*  Mark        :ver 1.0                                               */
   8          /***********************************************************************/ 
   9          #include "key_and_Other.h"              // 按键
  10          
  11          void key_check(void)
  12          {
  13   1      //    if (TB_100ms)--TB_100ms;
  14   1      //    else{                            
  15   1      //        TB_100ms = BASE_100ms;
  16   1      //        FG_100ms = 1;       // 100mS FLAG
  17   1      //      }
  18   1        
  19   1        
  20   1         if(FG_1ms){
  21   2          FG_1ms=0; 
  22   2          if(TIME_power_on_AD)TIME_power_on_AD--;
  23   2          if(m_TimerRegMode)--m_TimerRegMode;        
  24   2          if(m_KeyDupliSetTimeout)--m_KeyDupliSetTimeout;
  25   2          if(m_TimerKeyMonitor)--m_TimerKeyMonitor;
  26   2          if(m_KeyDupli1stTimer)--m_KeyDupli1stTimer;
  27   2          else FG_d_StopKey=0;
  28   2          if  ( FG_d_StopKey &&m_KeyDupli1stTimer){
  29   3            time_led++;
  30   3            if(time_led>=100){time_led=0;PIN_LED=!PIN_LED;}
  31   3          }
  32   2          if(m_TimerKey)--m_TimerKey;
  33   2          
  34   2          if(TIME_BEEP_on)
  35   2          {
  36   3              //--TIME_BEEP_on;
  37   3              if(FG_beep_on==0)
  38   3              {
  39   4                  FG_beep_on=1;FG_beep_off=0;Beep_On();//BEEP_CSR2_BEEPEN=1; //2015.3.11修正
  40   4                  if(FG_LED_on)   PIN_LED=1;
  41   4              }
  42   3          }
  43   2          else if(TIME_BEEP_off)
  44   2          {
  45   3              //--TIME_BEEP_off;
  46   3              if(FG_beep_off==0)
  47   3              {
  48   4                  FG_beep_off=1;FG_beep_on=0;Beep_Off();//BEEP_CSR2_BEEPEN=0;  //2015.3.11修正
  49   4                  if(FG_LED_on)   PIN_LED=0;
  50   4              }
  51   3          }
  52   2          else if(TIME_BEEP_freq)
  53   2          {
  54   3              --TIME_BEEP_freq;
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 2   

  55   3              TIME_BEEP_on=BASE_TIME_BEEP_on;
  56   3              TIME_BEEP_off=BASE_TIME_BEEP_off;
  57   3              if(FG_beep_on==0)
  58   3              {
  59   4                  FG_beep_on=1;FG_beep_off=0;Beep_On();//BEEP_CSR2_BEEPEN=1;  //2015.3.11修正
  60   4                  if(FG_LED_on)PIN_LED=1;
  61   4              }      
  62   3          }
  63   2          else  FG_LED_on=0; 
  64   2          
  65   2      //    if(FG_BAT_value==0){START_AD_SAMPLER();FG_BAT_value=1;}
  66   2      //    else {ADC_read();FG_BAT_value=0;}
  67   2          _KeyInTx();
  68   2          if(FG_10s==1) return;   // 2015.1.31修正3
  69   2          _RegistrationMode();
  70   2          _DupliFuncSetMode();
  71   2          //ADC2_EOC_INT();
  72   2          ClearWDT(); // Service the WDT    
  73   2        }
  74   1      }
  75          
  76          
  77          void time_control(void)
  78          {
  79   1          if(FG_100ms){
  80   2              FG_100ms=0; 
  81   2              if(TIME_2s_RestTX)--TIME_2s_RestTX;    //2015.4.13修正    
  82   2              if(FG_PWRON==1){
  83   3                  if ((TB_5s)&&(m_KeyOptSetMode==0))  --TB_5s;
  84   3              }    
  85   2          }
  86   1          if(Time_Tx_Out == 0 && FLAG_APP_TX == 1)
  87   1          {
  88   2              FLAG_APP_TX = 0;
  89   2              PIN_TX_LED = 0;
  90   2              ML7345_SetAndGet_State(Force_TRX_OFF);
  91   2              ML7345_RESETN = 0;
  92   2              SpiGpio_UnInit();
  93   2              ML7345D_POWER = FG_NOT_allow_out;
  94   2          }
  95   1      }
  96          
  97          //
  98          /****************************************/
  99          /*                                                                              */
 100          /*                      Check Key for Tx                        */
 101          /*                                                                              */
 102          /*                        in  : none                            */
 103          /*                        out : none                            */
 104          /*                                                                              */
 105          /****************************************/
 106          //
 107          /*      Key data table  */
 108          //              ||||||||
 109          //              |||||||+ Auto Tx Stop
 110          //              ||||||++ Auto Tx Start
 111          //              |||||+++ Reg.
 112          //              ||||++++ Vent.
 113          //              |||+++++ Close
 114          //              ||++++++ Stop
 115          //              |+++++++ Open
 116          //              ++++++++ 1
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 3   

 117          //
 118          const   uchar   ct_KeyDataTable[]
 119          ={ 
 120                  /*      Reg. (0)        */
 121          0xFB,// 0b11111011,
 122          //      /*      Open (1)        */
 123          0xBF,// 0b10111111,
 124          //      /*      Stop (2)        */
 125          0xDF,// 0b11011111,
 126          //      /*      Close (3)       */
 127          0xEF,// 0b11101111,
 128          //      /*      Vent. (4)       */
 129          0xF7,// 0b11110111,
 130          //      /*      Open + Stop (5) */
 131          0x9F,// 0b10011111,
 132          //      /*      Open + Close (6)        */
 133          0xAF,// 0b10101111,
 134          //      /*      Open + Vent. (7)        */
 135          0xB7,// 0b10110111,
 136          //      /*      Open + Reg. (8) */
 137          0xBB,// 0b10111011,
 138          //      /*      Stop + Close (9)        */
 139          0xCF,// 0b11001111,
 140          //      /*      Stop + Reg. (10)        */
 141          0xDB,// 0b11011011,
 142          //      /*      Close + Reg. (11)       */
 143          0xEB,// 0b11101011,
 144          //      /*      Close + Vent. (12)      */
 145          0xE7,// 0b11100111,
 146          //      /*      Vent. + Reg. (13)       */
 147          0xF3,// 0b11110011,
 148          //      /*      Auto Tx start (14)      */
 149          0xFD,// 0b11111101,
 150          //      /*      Auto Tx stop (15)       */
 151          0xFE,// 0b11111110,
 152          //      /*      No push (16)    */
 153          0xFF,// 0b11111111,
 154          } ;
 155          
 156          //
 157          void    _KeyInTx( void )
 158          {
 159   1              idata uchar     i ;
 160   1              
 161   1              m_KindOfKey = d_Idle ;
 162   1              
 163   1              m_KeyNew = 0xFF ;
 164   1              if(BAT_out==2)return;
 165   1                      
 166   1              /*      Registration sw         */
 167   1              _SwIn( PIN_KEY_OPEN ) ;
 168   1              /*      Auto Tx Start sw                */
 169   1              _SwIn( PIN_KEY_STOP ) ;
 170   1              /*      Auto Tx Stop sw         */
 171   1              _SwIn( PIN_KEY_CLOSE ) ;
 172   1              /*      Auto Tx Vent. sw                */
 173   1              _SwIn( PIN_KEY_VENT ) ; 
 174   1              //_SwIn( 1 ) ;
 175   1              /*      Auto Tx Reg. sw         */
 176   1              _SwIn( PIN_KEY_LOGIN ) ;        
 177   1              /*      Auto Tx Auto Tx Start sw                */
 178   1              _SwIn( 1 ) ;    
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 4   

 179   1              /*      Auto TxAuto Tx Stop sw          */
 180   1              _SwIn( 1 ) ;    
 181   1              
 182   1              
 183   1              if      ( m_KeyNew != m_KeyOld )                                // Key in
 184   1              {                                                                                               // Different with the last state
 185   2                      m_KeyOld = m_KeyNew ;
 186   2                      _SetKeyChatterCount() ;                                         // Chatter counter set
 187   2                      _ClearSpecialMultiKeyState() ;                          // Clear key continue state
 188   2                      TIME_Once_twice_switch=5000;   //2015.1.31修正4
 189   2                      TIME_10s=10100;  //2015.1.31修正3
 190   2                      return ;
 191   2              }
 192   1              
 193   1              if      ( --m_ChatterCount )                                            // Chattering ok ?
 194   1              {
 195   2                      return ;
 196   2              }
 197   1              m_ChatterCount = 1 ;
 198   1              
 199   1              /*              For generate Batt. Low tone             */
 200   1              if      ( m_KeyNew != d_KeyNoPush )                     // Is key data no push ?
 201   1              {                                                                                               // No, any key push
 202   2      //              if      ( m_BattState )                                                 // Batt. Low ?
 203   2      //              {                                                                                       // Yes
 204   2      //                      _ReqBuzzer(d_BuzBattLow) ;                              // Request
 205   2      //              }
 206   2                  //if(BAT_value>1000){
 207   2                 if(TIME_Once_twice_switch)--TIME_Once_twice_switch;    //2015.1.31修正4
 208   2                 if(TIME_10s)--TIME_10s;    //2015.1.31修正3
 209   2                 //dd_set_ADF7021_Power_on_Init();
 210   2                  dd_set_ML7345D_Power_on_Init();
 211   2                 if((BAT_out==1)||(FG_BAT)||(TIME_10s==0)){   //2015.1.31修正3
 212   3                    if(FG_BAT==0){
 213   4                              FG_BAT=1;
 214   4                              if(TIME_10s==0){      //2015.1.31修正3
 215   5                                 BASE_TIME_BEEP_on=103;
 216   5                                 BASE_TIME_BEEP_off=103;
 217   5                              }
 218   4                              else {
 219   5                                 BASE_TIME_BEEP_on=40;
 220   5                                 BASE_TIME_BEEP_off=60;
 221   5                              }
 222   4                              TIME_BEEP_on=BASE_TIME_BEEP_on;
 223   4                              TIME_BEEP_off=BASE_TIME_BEEP_off;
 224   4                              TIME_BEEP_freq=2;       
 225   4                    }
 226   3                    else if(TIME_BEEP_freq<=1)TIME_BEEP_freq=2;
 227   3                  }
 228   2              }
 229   1                      
 230   1              /*              Search of valid key             */
 231   1              for     ( i=0; i<17;i++)
 232   1              {
 233   2                      if      ( m_KeyNew == ct_KeyDataTable[i] )      // Match ?
 234   2                      {
 235   3                              m_KeyNo = i ;
 236   3                              break ;                                                                 // Yes
 237   3                      }
 238   2              }
 239   1              key_Value=i;   // 2015.1.31修正3
 240   1              if(FG_10s==1)return;   // 2015.1.31修正3
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 5   

 241   1              
 242   1              if      ( i == 17)                      // Found ?
 243   1              {                                                                                               // No
 244   2                      mb_NoPush = d_Clear ;                                           // No push clear(Push on)
 245   2                      _ClearSpecialMultiKeyState() ;                          // Special multi key status clear
 246   2                      mb_NoPushWait = d_On ;                                          // Set no push wait
 247   2                      _DupliFuncClear() ;                                                     // Duplicate key function clear
 248   2                      return ;
 249   2              }
 250   1              
 251   1              if      ( mb_NoPushWait )                                                       // Wait for no push ?
 252   1              {                                                                                               // Yes
 253   2                      if      ( m_KeyNew != d_KeyNoPush )             // Is key data no push ?
 254   2                      {
 255   3                              if(((i==5)||(i==6)||(i==7)||(i==9)||(i==12))&&(FLAG_APP_TX==0));    //解决复数输出
             -，按键未松一直发送 
 256   3                              else return ;                                                           // No
 257   3                      }
 258   2              }
 259   1              
 260   1              switch  ( i )    // Jumo to key function
 261   1              {
 262   2                      case 0 :
 263   2                              _FuncReg();
 264   2                              break ;         
 265   2                      case 1 :
 266   2                      case 2 :  
 267   2                      case 3 : 
 268   2                      case 4 :   
 269   2                              if(FLAG_APP_TX==0)_FuncStop();   //2015.1.31修正4
 270   2                              break ; 
 271   2                      case 5 :  
 272   2                      case 6 :  
 273   2                      case 7 :  
 274   2                      case 9 :  
 275   2                      case 12 :  
 276   2                              _FuncOpenStop();
 277   2                              break ;         
 278   2                      case 8 :  
 279   2                              _FuncOpenReg();
 280   2                              break ;
 281   2                      case 10 :  
 282   2                              _FuncStopReg();
 283   2                              break ;
 284   2                      case 11 :  
 285   2                              _FuncCloseReg();
 286   2                              break ;
 287   2                      case 13 :  
 288   2                              _FuncVentReg();
 289   2                              break ;
 290   2                      case 14 :  
 291   2                              _FuncAutoTxStart();
 292   2                              break ;
 293   2                      case 15 :  
 294   2                              _FuncAutoTxStop();
 295   2                              break ;
 296   2                      case 16 :  
 297   2                              _FuncNoPush();
 298   2                              break ;
 299   2              }
 300   1      }
 301          /*----------------------------------*/
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 6   

 302          /*                                                                      */
 303          /*              Open + Stop(5) function         */
 304          /*              Open + Close(6) function        */
 305          /*              Open + Vent.(7) function        */
 306          /*              Stop + Close(9) function        */
 307          /*              Close + Vent.(12) function      */
 308          /*                                                                      */
 309          /*----------------------------------*/
 310          //
 311          void    _FuncOpenStop( void )
 312          {
 313   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 314   1              m_KindOfKey = d_Idle ;
 315   1              _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 316   1              _ClearSpecialMultiKeyState() ;                                  // Special multi key status clear
 317   1              mb_NoPush = d_Clear ;
 318   1              mb_NoPushWait = d_On ;
 319   1      }
 320          /*----------------------------------*/
 321          /*                                                                      */
 322          /*              Open + Reg. function            */
 323          /*                                                                      */
 324          /*----------------------------------*/
 325          //
 326          void    _FuncOpenReg( void )
 327          {
 328   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 329   1              mb_NoPush = d_Clear ;
 330   1              if      ( !mb_RegOpenSw )                                                       // Continue push ?
 331   1              {                                                                                               // No
 332   2                      mb_RegOpenSw = d_On ;
 333   2                      m_TimerKey = d_Time3s ; // Set 3sec key timer
 334   2                      if(FG_PWRON==0){
 335   3                         FG_PWRON=1;
 336   3                         PIN_POWER_CONTROL=1;
 337   3                         TB_5s=TB_60s;//60;  //5.1秒
 338   3                      }
 339   2                      return ;
 340   2              }
 341   1              
 342   1              _Pass3secKey( d_ReqOpenReg ) ;
 343   1      }
 344          /*----------------------------------*/
 345          /*                                                                      */
 346          /*              Close + Reg. function           */
 347          /*                                                                      */
 348          /*----------------------------------*/
 349          //
 350          void    _FuncCloseReg( void )
 351          {
 352   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 353   1              if      ( !mb_RegCloseSw )                                                      // Continue push ?
 354   1              {                                                                                               // No
 355   2                      mb_RegCloseSw = d_On ;
 356   2                      m_TimerKey = d_Time3s ;                                         // Set 3sec key timer
 357   2                      if(FG_PWRON==0){
 358   3                         FG_PWRON=1;
 359   3                         PIN_POWER_CONTROL=1;
 360   3                         TB_5s=TB_60s;//60;  //5.1秒
 361   3                      }
 362   2                      return ;
 363   2              }
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 7   

 364   1              
 365   1              _Pass3secKey( d_ReqCloseReg ) ;
 366   1      }
 367          /*----------------------------------*/
 368          /*                                                                      */
 369          /*              Vent. + Reg. function           */
 370          /*                                                                      */
 371          /*----------------------------------*/
 372          //
 373          void    _FuncVentReg( void )
 374          {
 375   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 376   1              if      ( !mb_RegVentSw )                                                       // Continue push ?
 377   1              {                                                                                               // No
 378   2                      mb_RegVentSw = d_On ;
 379   2                      m_TimerKey = d_Time3s ;                                         // Set 3sec key timer
 380   2                      if(FG_PWRON==0){
 381   3                         FG_PWRON=1;
 382   3                         PIN_POWER_CONTROL=1;
 383   3                         TB_5s=TB_60s;//60;  //5.1秒
 384   3                      }
 385   2                      return ;
 386   2              }
 387   1              
 388   1              _Pass3secKey( d_ReqVentReg ) ;
 389   1      }
 390          /*----------------------------------*/
 391          /*                                                                      */
 392          /*              Stop + Reg. function            */
 393          /*                                                                      */
 394          /*----------------------------------*/
 395          //
 396          void    _FuncStopReg( void )
 397          {
 398   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 399   1              if      ( !mb_RegStopSw )                                                       // Continue push ?
 400   1              {                                                                                               // No
 401   2                      mb_RegStopSw = d_On ;
 402   2                      m_TimerKey = d_Time3s ;                                         // Set 3sec key timer
 403   2                      if(FG_PWRON==0){
 404   3                         FG_PWRON=1;
 405   3                         PIN_POWER_CONTROL=1;
 406   3                         TB_5s=TB_60s;//60;  //5.1秒
 407   3                      }
 408   2                      return ;
 409   2              }
 410   1              
 411   1              _Pass3secKey( d_ReqStopReg ) ;
 412   1      }
 413          void    _Pass3secKey( uchar req )
 414          {
 415   1              if      ( m_TimerKey )                                                          // 3sec passed ?
 416   1              {
 417   2                      if      ( !--m_TimerKey )
 418   2                      {                                                                                       // Yes
 419   3                              _ReqTxdEdit( req,0 ) ;
 420   3                              FG_Complex_Single_shot=1;   //2015.1.31修正2
 421   3                              return ;
 422   3                      }
 423   2              }
 424   1      }
 425          /*------------------------------------------*/
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 8   

 426          /*                                                                                      */
 427          /*              Open/Stop/Close/Vent. function          */
 428          /*                                                                                      */
 429          /*------------------------------------------*/
 430          void    _FuncReg( void )
 431          {
 432   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 433   1              if      ( mb_NoPush )                                                           // No push before ?
 434   1              {                                                                                               // Yes
 435   2                      mb_NoPush = d_Clear ;
 436   2                      m_KindOfKey = d_RegKey ;
 437   2                      _ClearSpecialMultiKeyState() ;                          // Special multi key status clear
 438   2                      mb_RegSw = d_On ;
 439   2                      m_TimerKey = d_Time3s ;                                         // Set 3sec key timer
 440   2                      if      ( !m_TimerKeyMonitor )                                  // 1st entry ?
 441   2                      {       // Yes
 442   3                                if(FG_PWRON==0){
 443   4                                   FG_PWRON=1;
 444   4                                   PIN_POWER_CONTROL=1;
 445   4                                   TB_5s=51;//TB_51s;//51;  //5.1秒
 446   4                                }     
 447   3                              m_TimerKeyMonitor = d_Time10s ;                 // Set 10sec key timer
 448   3                              m_KeyCount = 2 ;
 449   3                              return ;
 450   3                      }
 451   2                      if      ( !--m_KeyCount )                                               // ID registration mode ?
 452   2                      {
 453   3                              _SetRegistrationMode( d_RegAppend ) ;
 454   3                              m_KindOfKey = d_Idle ;
 455   3                              mb_NoPushWait = d_On ;                                  // Set no push wait
 456   3                      }
 457   2                      return ;
 458   2              }
 459   1              
 460   1              /*              Reg.sw push             */
 461   1              if      ( mb_RegSw )                                                            // Continue push ?
 462   1              {                                                                                               // Yes
 463   2                      if      ( m_TimerKey )                                                  // 3sec passed ?
 464   2                      {
 465   3                              if      ( !--m_TimerKey )
 466   3                              {                                                                               // Yes
 467   4                                      _SetRegistrationMode( d_RegDelete ) ;   // ID delete mode set
 468   4                                      m_KindOfKey = d_Idle ;
 469   4                                      mb_NoPushWait = d_On ;                          // Set no push wait
 470   4                              }
 471   3                              return ;                                                                // No
 472   3                      }
 473   2              }  
 474   1      }
 475          void    _FuncStop( void )
 476          {
 477   1              if      ( _GetNoPushState() )                                           // No push before ?
 478   1              {                                                                                               // No
 479   2                      if      ( mb_OpenSw || mb_StopSw || mb_CloseSw )// Continue push ?
 480   2                      {                                                                                       // Yes
 481   3                              if      (( !m_TimerKey )&&(FG_BAT==0)&&(TIME_Once_twice_switch==0))  //2015.1.31修正4     // 5sec passed ?
 482   3                              {
 483   4      //                              if      ( !--m_TimerKey )
 484   4      //                              {                                                                       // Yes
 485   4                                              if      ( mb_OpenSw || mb_CloseSw )                             // Close sw ?
 486   4                                              {
 487   5                                                      m_KeyOptSetMode = 10 ;                          // Yes
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 9   

 488   5                                                      //_ReqBuzzer( d_BuzOpt5 ) ;
 489   5                                                      //_ReqBuzzer(103,103,100);
 490   5                                                      m_KindOfKey = d_Idle ;
 491   5                                                      mb_NoPushWait = d_On ;                  // Set no push wait
 492   5                                                      return ;
 493   5                                              }
 494   4                                              m_KeyOptSetMode = 1 ;                   // Opetion setting mode
 495   4                                              //_ReqBuzzer( d_BuzOpt1 ) ;
 496   4                                              _ReqBuzzer(103,103,1);
 497   4                                                      FG_LED_on=1;
 498   4                                                      if(FG_PWRON==0){
 499   5                                                          FG_PWRON=1;
 500   5                                                          PIN_POWER_CONTROL=1;
 501   5                                                          TB_5s=TB_51s;//51;  //5.1秒
 502   5                                                      }
 503   4                                              m_KeyDupliSetTimeout = d_DupliTime4s ;
 504   4                                              m_KindOfKey = d_Idle ;
 505   4                                              mb_NoPush=d_Off;
 506   4                                              mb_NoPushWait = d_On ;                  // Set no push wait
 507   4                                              m_KeyOptSetOpenStop = 1 ;
 508   4                                              if      ( mb_OpenSw )                           // Open ?
 509   4                                              {
 510   5                                                      m_KeyOptSetOpenStop = 0 ;       // Yes
 511   5                                              }
 512   4      //                              }
 513   4      //                              return ;                                                        // No
 514   4                              }
 515   3                              return ;
 516   3                      }
 517   2                      return ;
 518   2              }
 519   1              
 520   1              m_KindOfKey = m_KeyNo ;
 521   1              if      ( m_KeyOptSetMode ||m_RegMode)                                                  // Option setting mode ?
 522   1              {
 523   2                      return ;                                                                        // Yes
 524   2              }
 525   1              
 526   1              switch  ( m_KindOfKey )
 527   1              {
 528   2                      case d_OpenKey :
 529   2                              mb_OpenSw = d_On ;
 530   2                              m_TimerKey = d_Time5s ;                                 // Set 5sec key timer
 531   2                              break;
 532   2                              
 533   2                      case d_StopKey :
 534   2                              mb_StopSw = d_On ;
 535   2                              m_TimerKey = d_Time5s ;                                 // Set 5sec key timer
 536   2                              break;
 537   2                              
 538   2                      case d_CloseKey :
 539   2                              mb_CloseSw = d_On ;
 540   2                              m_TimerKey = d_Time5s ;//d_Time9s ;                                     // Set 5sec key timer
 541   2                              break;
 542   2              }
 543   1              
 544   1                /********2015.1.31追加  按一次模式********/
 545   1              if      ( !rom_KeyOpt || m_KindOfKey == d_VentKey  )// Single push option or Vent. key ?
 546   1              
 547   1      //          /********2015.1.31追加  按2次模式********/
 548   1      //      if      ( rom_KeyOpt || m_KindOfKey == d_VentKey  )// Single push option or Vent. key ?        
 549   1              {                                                                                               // Yes
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 10  

 550   2                      _DupliFuncClear() ;                                                     // Duplicate key function clear
 551   2                      _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 552   2                      m_TimerKeyMonitor = d_Clear ;
 553   2                      return ;
 554   2              }
 555   1              
 556   1              /*      Multi push option       */
 557   1              if      ( m_KeyOptSetMode || m_RegMode )
 558   1              {
 559   2                      return ;
 560   2              }
 561   1              
 562   1              if      ( m_KindOfKey == d_StopKey )
 563   1              {
 564   2                      _DupliFuncClear() ;                                                     // Duplicate key function clear
 565   2                      _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 566   2                      m_TimerKeyMonitor = d_Clear ;
 567   2                      FG_d_StopKey=1;
 568   2                      m_KeyDupli1stTimer = d_D1stTime3s ;
 569   2                      time_led=0;
 570   2                      return ;
 571   2              }
 572   1              
 573   1              switch  ( m_KindOfKey )
 574   1              {
 575   2      //              case d_OpenKey :
 576   2      //                      m_KeyCloseCount = 2 ;
 577   2      //                      if      ( !--m_KeyOpenCount )
 578   2      //                      {
 579   2      //                              _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 580   2      //                              m_TimerKeyMonitor = d_Clear ;
 581   2      //                              _DupliFuncClear() ;                                     // Duplicate key function clear
 582   2      //                              return ;
 583   2      //                      }
 584   2      //                      m_KeyDupli1stTimer = d_D1stTime3s ;
 585   2      //                      break;
 586   2      //                      
 587   2      //              case d_CloseKey :
 588   2      //                      m_KeyOpenCount = 2 ;
 589   2      //                      if      ( !--m_KeyCloseCount )
 590   2      //                      {
 591   2      //                              _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 592   2      //                              m_TimerKeyMonitor = d_Clear ;
 593   2      //                              _DupliFuncClear() ;                                     // Duplicate key function clear
 594   2      //                              return ;
 595   2      //                      }
 596   2      //                      m_KeyDupli1stTimer = d_D1stTime3s ;
 597   2      //                      break;
 598   2                
 599   2                      case d_OpenKey :
 600   2                      case d_CloseKey :  
 601   2                              if      ( FG_d_StopKey && m_KeyDupli1stTimer)
 602   2                              {
 603   3                                      FG_d_StopKey=0;
 604   3                                      m_KeyDupli1stTimer=0;
 605   3                                      _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 606   3                                      m_TimerKeyMonitor = d_Clear ;
 607   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 608   3                                      return ;
 609   3                              }
 610   2                              break;
 611   2                                              
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 11  

 612   2              }  
 613   1      }
 614          
 615          void    _FuncAutoTxStart( void )
 616          {
 617   1        
 618   1      }
 619          void    _FuncAutoTxStop( void )
 620          {
 621   1        
 622   1      }
 623          void    _FuncNoPush( void )
 624          {
 625   1              mb_OpenSw = d_Off ;                                                     // For duplicate keyvfunction
 626   1              mb_StopSw = d_Off ;
 627   1              mb_CloseSw = d_Off ;
 628   1              FG_BAT=0;
 629   1              
 630   1              _ClearSpecialMultiKeyState() ;                          // Special multi key status clear
 631   1              mb_NoPush     = d_On ;                                          // No push on
 632   1              mb_NoPushWait = d_Off ;                                         // No push wait clear
 633   1              m_KindOfKey = d_KeyNoPush;//d_NoPushKey ;
 634   1      //      if      ( m_BuzzerMode == d_BuzBattLow )                        // Batt.Low sound out ?
 635   1      //      {
 636   1      //              _BuzIdle() ;
 637   1      //      }  
 638   1      }
 639          void    _SetKeyChatterCount( void )
 640          {
 641   1              m_ChatterCount = d_Time50ms ;                                           // Chatter counter set
 642   1              m_TimerKey = 0 ;
 643   1      }
 644          /*==============================================*/
 645          /*                                                                                              */
 646          /*              Clear special multi key push status             */
 647          /*                                                                                              */
 648          /*                       in  : none                                                     */
 649          /*                       out : none                                                     */
 650          /*                                                                                              */
 651          /*==============================================*/
 652          //
 653          void    _ClearSpecialMultiKeyState( void )
 654          {
 655   1              mb_RegSw      = d_Clear ;
 656   1              mb_RegStopSw  = d_Clear ;
 657   1              mb_RegOpenSw  = d_Clear ;
 658   1              mb_RegCloseSw = d_Clear ;
 659   1              mb_RegVentSw  = d_Clear ;
 660   1      }
 661          /****************************************/
 662          /*                                                                              */
 663          /*              Key duplicate function clear    */
 664          /*                                                                              */
 665          /*                        in  : none                            */
 666          /*                        out : none                            */
 667          /*                                                                              */
 668          /****************************************/
 669          //
 670          void    _DupliFuncClear( void )
 671          {
 672   1              m_KeyOptSetMode = d_Idle ;
 673   1              m_KeyOpenCount = 2 ;
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 12  

 674   1              m_KeyCloseCount = 2 ;
 675   1              //mb_OpenSw = d_Off ;
 676   1              //mb_StopSw = d_Off ;
 677   1              if      ( m_KeyDupli1stTimer )
 678   1              {
 679   2                      m_KeyDupli1stTimer = d_Clear ;
 680   2                      //_LedOnOff( d_LedOff ) ;                               // Led off
 681   2              }
 682   1      }
 683          /*==============================================*/
 684          /*                                                                                              */
 685          /*                      No Push(Last time) check                        */
 686          /*                                                                                              */
 687          /*                       in  : none                                                     */
 688          /*                       out : 0: No push                                       */
 689          /*                                 1: any push                                  */
 690          /*                                                                                              */
 691          /*==============================================*/
 692          //
 693          u8 _GetNoPushState(void)
 694          {
 695   1              if      (!mb_NoPush)                                                            // No push before ?
 696   1              {                                                                                               // No
 697   2                      return(d_NG) ;
 698   2              }
 699   1              
 700   1              mb_NoPush = d_Clear ;
 701   1      //      /*              Set Auto Tx inhibit             */
 702   1      //      mb_AutoTxInhibit = d_On ;                               // Inhibit
 703   1      //      mb_AutoTxOnOff   = d_Off ;                              // Off
 704   1      //      
 705   1              m_TimerKey = d_Clear ;
 706   1              _ClearSpecialMultiKeyState() ;                                  // Special multi key status clear
 707   1              return(d_OK) ;
 708   1      }
 709          
 710          void _ReqTxdEdit(u8 txreq ,u8 buzreq )  // Tx data edit request
 711          {
 712   1          u8 time_key;
 713   1          if((TB_sum_5s<69)&&(FG_PWRON==1)&&(TB_5s<25))
 714   1          {      //计算剩余的时间，总共时间不能超过69，以25为间隔。
 715   2              time_key=25-TB_5s;
 716   2              TB_sum_5s=TB_sum_5s+time_key;
 717   2              if((69-TB_sum_5s)>=27)  TB_5s=25;
 718   2          }
 719   1          if((TB_5s>=25)||(TIME_2s_RestTX==0))
 720   1          {   //2015.4.13修正
 721   2              if(FG_PWRON==0)
 722   2              {
 723   3                  FG_PWRON=1;
 724   3                  PIN_POWER_CONTROL=1;
 725   3                  TB_5s=TB_51s;//51;  //5.1秒
 726   3              }
 727   2              switch  ( txreq )    // Jumo to key function
 728   2              {
 729   3                  case 1 :
 730   3                          Control_code=0x08;     //open
 731   3                      break ;
 732   3                  case 2 :    
 733   3                          Control_code=0x04;    //stop
 734   3                      break ;
 735   3                  case 3 :    
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 13  

 736   3                          Control_code=0x02;    //close
 737   3                      break ;
 738   3                  case 4 :    
 739   3                          Control_code=0x01;    //vnet 换气
 740   3                      break ;
 741   3                  case 10 :                 //Stop + Reg
 742   3                          Control_code=0x14;
 743   3                      break ; 
 744   3                  case 5 :                      //Open + Stop    
 745   3                          Control_code=0x0C;
 746   3                          break ;     
 747   3                  case 6 :                   //Open + Close
 748   3                         Control_code=0x0A;
 749   3                          break ;     
 750   3                  case 7 :                   //Open + Vent
 751   3                         Control_code=0x09;
 752   3                          break ;     
 753   3                  case 9 :                //Stop + Close
 754   3                         Control_code=0x06;
 755   3                          break ;     
 756   3                  case 12 :              //Close + Vent.
 757   3                         Control_code=0x03;
 758   3                          break ;     
 759   3              }
 760   2              switch  ( buzreq )    // Jumo to key function
 761   2              {
 762   3                  case 1 :
 763   3                         _ReqBuzzer(103,103,0);
 764   3          //                  BASE_TIME_BEEP_on=103;
 765   3          //                        BASE_TIME_BEEP_off=103;
 766   3          //                  TIME_BEEP_freq=0;
 767   3                      break ;
 768   3                  case 2 :
 769   3                         _ReqBuzzer(103,103,1);
 770   3          //                  BASE_TIME_BEEP_on=103;
 771   3          //                        BASE_TIME_BEEP_off=103;
 772   3          //                  TIME_BEEP_freq=1;
 773   3                      break ;
 774   3                  case 3 :    
 775   3                        _ReqBuzzer(103,103,2);
 776   3          //                  BASE_TIME_BEEP_on=103;
 777   3          //                        BASE_TIME_BEEP_off=103;
 778   3          //                  TIME_BEEP_freq=2;
 779   3                      break ;
 780   3                  case 4 :    
 781   3                        _ReqBuzzer(500,10,0);
 782   3                        break ;
 783   3                  case 20 :   
 784   3                         _ReqBuzzer(1000,10,0);
 785   3          //                  BASE_TIME_BEEP_on=1000;
 786   3          //                        BASE_TIME_BEEP_off=1;
 787   3          //                  TIME_BEEP_freq=0;
 788   3                      break ;
 789   3              }       
 790   2              dd_set_ML7345D_Power_on();
 791   2              PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 792   2              RF_ML7345_Init(Fre_426_075,0x15,12);    
 793   2              SendTxData();
 794   2              TIME_2s_RestTX = 25;       //2015.4.13修正        
 795   2        }
 796   1        else PIN_LED=0;
 797   1      }
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 14  

 798          
 799          //
 800          /************************************************/
 801          /*                                                                                              */
 802          /*              Key duplicate function setting mode             */
 803          /*                              Every 10ms                                              */
 804          /*                                                                                              */
 805          /*                        in  : none                                            */
 806          /*                        out : none                                            */
 807          /*                                                                                              */
 808          /************************************************/
 809          //
 810          void    _DupliFuncSetMode( void )
 811          {
 812   1        u8 m_KeyOpt;
 813   1              switch  ( m_KeyOptSetMode )
 814   1              {
 815   2                      case 1 :
 816   2                              if      ( !mb_NoPushWait )                                      // No push ?
 817   2                              {
 818   3                                      m_KeyDupliSetTimeout = d_DupliTime1s ;  // Yes
 819   3                                      ++m_KeyOptSetMode ;
 820   3                                      return ;
 821   3                              }
 822   2                              if      ( !m_KeyDupliSetTimeout )                       // Pushing 9s over ?
 823   2                              {
 824   3                                      m_KeyOptSetMode = 10 ;                          // Yes
 825   3                                      //_ReqBuzzer( d_BuzOpt5 ) ;
 826   3                                      //_ReqBuzzer(103,103,100);
 827   3                                      
 828   3                              }
 829   2                              break ;
 830   2                              
 831   2                      case 2 :
 832   2                              if      ( !m_KeyDupliSetTimeout )                       // Wait 1s ok ?
 833   2                              {                                                                               // Yes
 834   3                                      ++m_KeyOptSetMode;
 835   3                                      m_KeyDupliSetTimeout = d_DupliTime3s ;
 836   3                                      //_ReqBuzzer( d_BuzOpt2 ) ;
 837   3                                      _ReqBuzzer(103,103,0);
 838   3                                      FG_LED_on=1;
 839   3                              }
 840   2                              
 841   2                              if      ( m_KindOfKey != d_Idle && m_KindOfKey != d_KeyNoPush )
 842   2                              {
 843   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 844   3                              }
 845   2                              break ;
 846   2                              
 847   2                      case 3 :                                                                        // Sw in wait
 848   2                              if      ( !m_KeyDupliSetTimeout )
 849   2                              {
 850   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 851   3                                      return ;
 852   3                              }
 853   2                              
 854   2                              if      ( m_KindOfKey == d_Idle || m_KindOfKey == d_KeyNoPush )
 855   2                              {
 856   3                                      return ;
 857   3                              }
 858   2                              
 859   2                              if      ( m_KeyOptSetOpenStop )                         // Setting by stop ?
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 15  

 860   2                              {                                                                               // Yes
 861   3                                      if      ( m_KindOfKey == d_StopKey )
 862   3                                      {
 863   4                                              m_KeyDupliSetTimeout = d_DupliTime1s ;
 864   4                                              ++m_KeyOptSetMode ;
 865   4                                              //mb_NoPushWait = d_On ;
 866   4                                      }
 867   3                                      else
 868   3                                      {                                                                       // Error
 869   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 870   4                                              return ;
 871   4                                      }
 872   3                              }
 873   2                              else
 874   2                              {
 875   3                                      if      ( m_KindOfKey == d_OpenKey )
 876   3                                      {
 877   4                                              m_KeyDupliSetTimeout = d_DupliTime1s ;
 878   4                                              ++m_KeyOptSetMode ;
 879   4                                              
 880   4                                      }
 881   3                                      else
 882   3                                      {                                                                       // Error
 883   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 884   4                                              return ;
 885   4                                      }
 886   3                              }
 887   2                              break ;
 888   2                              
 889   2                      case 4 :
 890   2                              if      ( !m_KeyDupliSetTimeout )                       // Wait 1s ok ?
 891   2                              {                                                                               // Yes
 892   3                                      ++m_KeyOptSetMode ;
 893   3                                      m_KeyDupliSetTimeout = d_DupliTime3s ;
 894   3                                      //_ReqBuzzer( d_BuzOpt2 ) ;
 895   3                                      _ReqBuzzer(103,103,0);
 896   3                                      FG_LED_on=1;
 897   3                              }
 898   2      //                      
 899   2      //                      if      ( m_KindOfKey != d_Idle && m_KindOfKey != d_KeyNoPush  )
 900   2      //                      {                                                                               // Error
 901   2      //                              _DupliFuncClear() ;                                     // Duplicate key function clear
 902   2      //                      }
 903   2                              break ;
 904   2                              
 905   2                      case 5 :                                                                        // Sw in wait
 906   2                              if      ( !m_KeyDupliSetTimeout )
 907   2                              {
 908   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 909   3                                      return ;
 910   3                              }
 911   2                              
 912   2                              if      ( m_KindOfKey == d_Idle || m_KindOfKey == d_KeyNoPush )
 913   2                              {
 914   3                                      return ;
 915   3                              }
 916   2                              
 917   2                              if      ( m_KeyOptSetOpenStop )                         // Setting by stop ?
 918   2                              {                                                                               // Yes
 919   3                                      if      ( m_KindOfKey == d_StopKey )
 920   3                                      {
 921   4                                              m_KeyDupliSetTimeout = d_DupliTime1s ;
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 16  

 922   4                                              ++m_KeyOptSetMode ;
 923   4                                              mb_NoPushWait = d_On ;
 924   4                                      }
 925   3                                      else
 926   3                                      {                                                                       // Error
 927   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 928   4                                              return ;
 929   4                                      }
 930   3                              }
 931   2                              else
 932   2                              {
 933   3                                      if      ( m_KindOfKey == d_OpenKey )
 934   3                                      {
 935   4                                              m_KeyDupliSetTimeout = d_DupliTime1s ;
 936   4                                              ++m_KeyOptSetMode ;
 937   4                                      }
 938   3                                      else
 939   3                                      {                                                                       // Error
 940   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 941   4                                              return ;
 942   4                                      }
 943   3                              }
 944   2                              break ;
 945   2                              
 946   2                      case 6 :
 947   2                              if      ( !m_KeyDupliSetTimeout )                       // Wait 1s ok ?
 948   2                              {                                                                               // Yes
 949   3                                      ++m_KeyOptSetMode ;
 950   3                                      m_KeyDupliSetTimeout = d_DupliTime3s ;
 951   3                                      //_ReqBuzzer( d_BuzOpt3 ) ;
 952   3                                      _ReqBuzzer(103,103,2);
 953   3                                      FG_LED_on=1;                            
 954   3                              }
 955   2                              
 956   2      //                      if      ( m_KindOfKey != d_Idle && m_KindOfKey != d_KeyNoPush )
 957   2      //                      {                                                                               // Error
 958   2      //                              _DupliFuncClear() ;                                     // Duplicate key function clear
 959   2      //                      }
 960   2                              break ;
 961   2                              
 962   2                      case 7 :                                                                        // Sw in wait
 963   2                              if      ( !m_KeyDupliSetTimeout )
 964   2                              {
 965   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 966   3                                      return ;
 967   3                              }
 968   2                              
 969   2                              if      ( m_KindOfKey == d_Idle || m_KindOfKey == d_KeyNoPush )
 970   2                              {
 971   3                                      return ;
 972   3                              }
 973   2                              
 974   2                              if      ( m_KeyOptSetOpenStop )                         // Setting by stop ?
 975   2                              {                                                                               // Yes
 976   3                                      if      ( m_KindOfKey == d_StopKey )
 977   3                                      {
 978   4                                              m_KeyDupliSetTimeout = d_DupliTime10s ;
 979   4                                              ++m_KeyOptSetMode ;
 980   4                                              mb_NoPushWait = d_On ;
 981   4                                      }
 982   3                                      else
 983   3                                      {                                                                       // Error
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 17  

 984   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 985   4                                              return ;
 986   4                                      }
 987   3                              }
 988   2                              else
 989   2                              {
 990   3                                      if      ( m_KindOfKey == d_OpenKey )
 991   3                                      {
 992   4                                              m_KeyDupliSetTimeout = d_DupliTime10s ;
 993   4                                              ++m_KeyOptSetMode ;
 994   4                                      }
 995   3                                      else
 996   3                                      {                                                                       // Error
 997   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 998   4                                              return ;
 999   4                                      }
1000   3                              }
1001   2                              break ;
1002   2                              
1003   2                      case 8 :                                                                        // Sw in wait
1004   2                      case 9 :                                                                        // Sw in wait
1005   2                              if      ( !m_KeyDupliSetTimeout )
1006   2                              {
1007   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
1008   3                                      return ;
1009   3                              }
1010   2                              
1011   2                              if      ( m_KindOfKey == d_Idle || m_KindOfKey == d_KeyNoPush )
1012   2                              {
1013   3                                      return ;
1014   3                              }
1015   2                              
1016   2                              if      ( m_KeyOptSetOpenStop )                         // Setting by stop ?
1017   2                              {                                                                               // Yes
1018   3                                      if      ( m_KindOfKey == d_StopKey )
1019   3                                      {
1020   4                                              if      ( m_KeyOptSetMode == 9 )
1021   4                                              {
1022   5                                                      m_KeyOpt = rom_KeyOpt ;
1023   5                                                      if      ( m_KeyOpt )
1024   5                                                      {
1025   6                                                              m_KeyOpt = 0 ;
1026   6                                                      }
1027   5                                                      else
1028   5                                                      {
1029   6                                                              m_KeyOpt = 1 ;
1030   6                                                      }
1031   5                                                      rom_KeyOpt = m_KeyOpt;
1032   5                              IAP_WriteBuf_With_Protect_Verify(addr_eeprom_sys+Addr_rom_KeyOpt,&rom_KeyOpt,1);
1033   5                                                      //KeyOpt_EEPROM_write();
1034   5                                                      //_FlashWriteID() ;                             // Write data to flash rom
1035   5                                                      
1036   5                                                      //_ReqBuzzer( d_BuzOpt4 ) ;
1037   5                                                      _ReqBuzzer(103,103,4);
1038   5                                                      FG_LED_on=1;    
1039   5                                                      FG_d_StopKey=0;
1040   5                                                      TB_5s=TB_20s;//20;
1041   5                                                      _DupliFuncClear() ;                             // Duplicate key function clear
1042   5                                                      return ;
1043   5                                              }
1044   4                                              ++m_KeyOptSetMode ;
1045   4                                      }
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 18  

1046   3                                      else
1047   3                                      {                                                                       // Error
1048   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
1049   4                                              return ;
1050   4                                      }
1051   3                              }
1052   2                              else
1053   2                              {
1054   3                                      if      ( m_KindOfKey == d_OpenKey )
1055   3                                      {
1056   4                                              if      ( m_KeyOptSetMode == 9 )
1057   4                                              {
1058   5                                                      m_KeyOpt = rom_KeyOpt ;
1059   5                                                      if      ( m_KeyOpt )
1060   5                                                      {
1061   6                                                              m_KeyOpt = 0 ;
1062   6                                                      }
1063   5                                                      else
1064   5                                                      {
1065   6                                                              m_KeyOpt = 1 ;
1066   6                                                      }
1067   5                                                      rom_KeyOpt=m_KeyOpt;
1068   5                              IAP_WriteBuf_With_Protect_Verify(addr_eeprom_sys+Addr_rom_KeyOpt,&rom_KeyOpt,1);
1069   5                                                      //KeyOpt_EEPROM_write();                                // Write data to flash rom
1070   5                                                      
1071   5                                                      //_ReqBuzzer( d_BuzOpt4 ) ;
1072   5                                                      _ReqBuzzer(103,103,4);
1073   5                                                      FG_LED_on=1;
1074   5                                                      FG_d_StopKey=0;
1075   5                                                      _DupliFuncClear() ;                             // Duplicate key function clear
1076   5                                                      
1077   5                                                      return ;
1078   5                                              }
1079   4                                              ++m_KeyOptSetMode ;
1080   4                                      }
1081   3                                      else
1082   3                                      {                                                                       // Error
1083   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
1084   4                                              return ;
1085   4                                      }
1086   3                              }
1087   2                              break ;
1088   2                              
1089   2                      case 10 :
1090   2                              if      ( !mb_NoPushWait )                                      // No push ?
1091   2                              {
1092   3                                      //_BuzIdle() ;
1093   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
1094   3                                      return ;
1095   3                              }
1096   2                              break ;
1097   2                              
1098   2              }
1099   1      }
1100          /****************************************/
1101          /*                                                                              */
1102          /*              Registration mode procedure             */
1103          /*                                                                              */
1104          /*                        in  : none                            */
1105          /*                        out : none                            */
1106          /*                                                                              */
1107          /****************************************/
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 19  

1108          //
1109          void    _RegistrationMode( void )
1110          {
1111   1              if      ( !_GetRegMode() )                                                      // Reg. mode Idle ?
1112   1              {                                                                                               // Yes
1113   2                      return ;
1114   2              }
1115   1      
1116   1              if(FG_PWRON==0){
1117   2              FG_PWRON=1;
1118   2              PIN_POWER_CONTROL=1;
1119   2              }       
1120   1              if(m_TimerRegMode){
1121   2                TB_5s=51;//TB_51s;//51;  //5.1秒
1122   2                time_led++;
1123   2                if(time_led>=500){time_led=0;PIN_LED=!PIN_LED;}         
1124   2              }
1125   1              else {
1126   2                      //_ReqBuzzer(500,250,3);
1127   2                      _ReqBuzzer(500,250,2);
1128   2                      PIN_LED=0;
1129   2                      m_RegMode = d_Idle ;
1130   2              }
1131   1              /*      Led control     */
1132   1      //      if      ( mb_LedOnOff )                                                         // Led on timing ?
1133   1      //      {                                                                                               // Yes
1134   1      //              _LedOnOff( d_LedOn ) ;                                          // Led on
1135   1      //      }
1136   1      //      else
1137   1      //      {
1138   1      //              _LedOnOff( d_LedOff ) ;                                         // Led off
1139   1      //      }
1140   1              
1141   1              switch  ( m_KindOfKey )
1142   1              {
1143   2                      case    d_OpenKey :
1144   2                              if      ( ++m_RegID[m_RegDigit] > '9' )         // No. up
1145   2                              {
1146   3                                      m_RegID[m_RegDigit] = '0' ;
1147   3                              }
1148   2                              //_ReqBuzzer(d_BuzOpen) ;
1149   2                              _ReqBuzzer(103,103,0);
1150   2                              m_TimerRegMode = d_Time1min ;                   // 1min. set (1s base)
1151   2                              break ;
1152   2                              
1153   2                      case    d_StopKey :                                             // Next digit
1154   2                              if      ( ++m_RegDigit > 8 )
1155   2                              {
1156   3                                      m_RegDigit= 8 ;
1157   3                              }
1158   2      /*              Add on 2007/5/28                */
1159   2                              else
1160   2                              {
1161   3                                      //_ReqBuzzer(d_BuzStop) ;
1162   3                                _ReqBuzzer(103,103,1);
1163   3                              }
1164   2      /*********************************/
1165   2      /*              Deleted on 2007/5/28            */
1166   2      //                      _ReqBuzzer(d_BuzStop) ;
1167   2      /*********************************/
1168   2                              m_TimerRegMode = d_Time1min ;                   // 1min. set (1s base)
1169   2                              break ;
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 20  

1170   2                              
1171   2                      case    d_CloseKey :
1172   2                              _IdClear() ;                                                    // ID clear
1173   2                              //_ReqBuzzer(d_BuzReg) ;
1174   2                              _ReqBuzzer(1000,10,0);
1175   2                              m_TimerRegMode = d_Time1min ;                   // 1min. set (1s base)
1176   2                              break ;
1177   2                              
1178   2                      case    d_RegKey :                                              // Send ID
1179   2      /*              Add on 2007/5/28                */
1180   2                              if      ( m_RegDigit < 8 )
1181   2                              {
1182   3                                      return ;
1183   3                              }
1184   2      /*********************************/
1185   2      
1186   2                              //_SetRegModeIdle() ;
1187   2                              //m_RegMode = d_Idle ;
1188   2                              ID_data_add.IDC = (ulong)atol(m_RegID) ;
1189   2      /*              Modified on 2007/5/28           */
1190   2      //                      if      ( m_RFID.ID > 16777215 )                        // Over ?
1191   2                              if      ( ID_data_add.IDC > 16777214 )                  // Over ?
1192   2      /*********************************/
1193   2                              {
1194   3                                      //_ReqBuzzer(d_BuzRegEnd) ;
1195   3                                      _ReqBuzzer(100,100,3);            
1196   3                              }
1197   2                              else
1198   2                              {
1199   3                                      _ReqTxdEdit(20,20) ;
1200   3                                    
1201   3                              }
1202   2                              m_RegMode = d_Idle ;
1203   2                              break ;
1204   2              }
1205   1      }
1206          //
1207          
1208          
1209          
1210          u32 atol (unsigned char* m_RegID_x)
1211          {
1212   1        u8 i,j;
1213   1        u32 m_ID=0;
1214   1          
1215   1        for(i=0;i<8;i++){
1216   2          j=m_RegID_x[i]-'0';
1217   2          m_ID=m_ID*10+j;
1218   2        }
1219   1        return(m_ID);
1220   1      }
1221          
1222          
1223          /************************************************/
1224          /*                                                                                              */
1225          /*                              Set registration mode                   */
1226          /*                                                                                              */
1227          /*              in  : mode( 0:Idle/1:Append/2:Delete )  */
1228          /*              out : none                                                              */
1229          /*                                                                                              */
1230          /************************************************/
1231          //
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 21  

1232          void    _SetRegistrationMode( uchar mode )
1233          {
1234   1              if      (_GetRegMode())                                                 // Reg. mode Idle ?
1235   1              {                                                                                               // No
1236   2                      return ;
1237   2              }
1238   1              
1239   1              m_RegMode = mode ;
1240   1      //      m_RFAddDelCode = 0x00 ;                                         // Set delete
1241   1      //      if      ( m_RegMode == d_RegAppend )                    // Append ?
1242   1      //      {                                                                                       // Yes
1243   1      //              m_RFAddDelCode = 0xFF ;                                 // Set Append
1244   1      //      }
1245   1              
1246   1              _IdClear() ;                                                            // ID clear
1247   1              
1248   1      //      _LedOnOff( d_LedOn ) ;                                          // Led on
1249   1      //      m_BlkTimer = d_Time500ms ;                                      // Blink start
1250   1      //      mb_LedOnOff = d_On ;
1251   1      //      
1252   1      //      _ReqBuzzer(d_BuzReg) ;
1253   1              _ReqBuzzer(1000,10,0);
1254   1              m_TimerRegMode = d_Time1min ;                           // 1min. set (1s base)
1255   1      }
1256          u8 _GetRegMode(void)
1257          {
1258   1              return(m_RegMode) ;
1259   1      }
1260          /********************************************/
1261          /*                                                                                      */
1262          /*                                      ID clear                                */
1263          /*                                                                                      */
1264          /********************************************/
1265          //
1266          void _IdClear(void)
1267          {
1268   1              register        uchar   i ;
1269   1              
1270   1              m_RegDigit = 0 ;                                                        // Digit pointer clear
1271   1              //m_RFID.ID  = 0 ;                                                      // ID Number clear
1272   1              for     ( i=0; i<8; i++ )                                               // ID clear
1273   1              {
1274   2                      m_RegID[i] = '0' ;
1275   2              }
1276   1              m_RegID[8] = 0 ;                                                        // NULL set
1277   1              
1278   1      }
1279          
1280          //
1281          /*--------------------------------------*/
1282          /*                                      */
1283          /*                      Sw data input   */
1284          /*                                      */
1285          /*                        in  : sw      */
1286          /*                        out : none    */
1287          /*                                      */
1288          /*--------------------------------------*/
1289          //
1290          void _SwIn(u8 sw)
1291          {
1292   1              m_KeyNew<<= 1 ;
1293   1              if      ( sw )
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 22  

1294   1              {
1295   2                      m_KeyNew |= d_On ;
1296   2              }
1297   1      }
1298          
1299          void _ReqBuzzer(u16 BEEP_on_SET,u8 BEEP_off_SET,u8 BEEP_freq_SET)
1300          {
1301   1          if(FG_BAT==0)
1302   1          {
1303   2              BASE_TIME_BEEP_on=BEEP_on_SET;
1304   2              BASE_TIME_BEEP_off=BEEP_off_SET;
1305   2              TIME_BEEP_on=BASE_TIME_BEEP_on;
1306   2              TIME_BEEP_off=BASE_TIME_BEEP_off;
1307   2              TIME_BEEP_freq=BEEP_freq_SET;
1308   2          }
1309   1      }
1310          
1311          void test_mode_control(void)
1312          {
1313   1      
1314   1          while(PIN_test_mode == 0)
1315   1          { 
1316   2              if(Flag_test_mode == 0)
1317   2                      {
1318   3                              Flag_test_mode = 1;
1319   3                              PIN_POWER_CONTROL = 1;
1320   3                  PIN_TX_LED = 1;
1321   3                              Init_Uart0_T1(); 
1322   3                  INT_EnAll(); 
1323   3                  Beep_On();
1324   3                  TIME_BEEP_off = 200;            
1325   3                  while(TIME_BEEP_off);
1326   3                  Beep_Off();
1327   3                      }
1328   2              ClearWDT(); // Service the WDT 
1329   2              if((PIN_KEY_OPEN==0)&&(FG_KEY_OPEN==0))
1330   2              {
1331   3                  FG_KEY_OPEN = 1;
1332   3                  dd_set_ML7345D_Power_on();
1333   3                  PROFILE_CH_FREQ_32bit_200002EC = 426075000;
1334   3                  RF_ML7345_Init(Fre_426_075,0x15,12);
1335   3                  FG_test_mode = 0;
1336   3                  Tx_Data_Test(0);
1337   3              }
1338   2              if(PIN_KEY_OPEN == 1) FG_KEY_OPEN = 0;
1339   2      
1340   2              if((PIN_KEY_STOP == 0)&&(FG_KEY_STOP == 0))
1341   2              {
1342   3                  FG_KEY_STOP = 1;
1343   3                  ML7345_RESETN = 0;
1344   3                  SpiGpio_UnInit(); 
1345   3                  ML7345D_POWER = FG_NOT_allow_out;
1346   3                  FG_test_mode = 0;
1347   3              }
1348   2              if(PIN_KEY_STOP == 1)   FG_KEY_STOP = 0; 
1349   2      
1350   2              if((PIN_KEY_CLOSE == 0) && (FG_KEY_CLOSE == 0))
1351   2              {
1352   3                  FG_KEY_CLOSE = 1;
1353   3                  dd_set_ML7345D_Power_on();
1354   3                  PROFILE_CH_FREQ_32bit_200002EC = 426075000;
1355   3                  RF_ML7345_Init(Fre_426_075,0x15,12);
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/25/2022 14:05:33 PAGE 23  

1356   3                  Tx_Data_Test(1);
1357   3                  FG_test_mode = 1;
1358   3              }
1359   2              if(PIN_KEY_CLOSE == 1)    FG_KEY_CLOSE=0;  
1360   2      
1361   2              PC_PRG();              // PC控制  
1362   2          }  
1363   1          if(Flag_test_mode == 1)
1364   1          {
1365   2              Flag_test_mode = 0;
1366   2              UART1_end();
1367   2          }
1368   1          PIN_POWER_CONTROL = 0;
1369   1          PIN_TX_LED = 0;
1370   1          FG_KEY_OPEN = 0;
1371   1          FG_KEY_STOP = 0;
1372   1          FG_KEY_CLOSE = 0;  
1373   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5463    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     38    ----
   IDATA SIZE       =      1    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
