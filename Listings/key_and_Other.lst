C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE KEY_AND_OTHER
OBJECT MODULE PLACED IN .\Objects\key_and_Other.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE user\src\key_and_Other.c OPTIMIZE(0,SPEED) BROWSE INCDIR(.\include;.\use
                    -r\inc) DEBUG OBJECTEXTEND PRINT(.\Listings\key_and_Other.lst) OBJECT(.\Objects\key_and_Other.obj)

line level    source

   1          /***********************************************************************/
   2          /*  FILE        :key_and_Other.c                                       */
   3          /*  DATE        :Mar, 2014                                             */
   4          /*  Programmer  :xiang 'R                                              */
   5          /*  CPU TYPE    :STM8S003     Crystal: 4M HSI                          */
   6          /*  DESCRIPTION :                                                      */
   7          /*  Mark        :ver 1.0                                               */
   8          /***********************************************************************/ 
   9          #include "key_and_Other.h"              // 按键
  10          
  11          void key_check(void)
  12          {
  13   1      //    if (TB_100ms)--TB_100ms;
  14   1      //    else{                            
  15   1      //        TB_100ms = BASE_100ms;
  16   1      //        FG_100ms = 1;       // 100mS FLAG
  17   1      //      }
  18   1        
  19   1        
  20   1         if(FG_1ms){
  21   2          FG_1ms=0; 
  22   2          if(TIME_power_on_AD)TIME_power_on_AD--;
  23   2          if(m_TimerRegMode)--m_TimerRegMode;        
  24   2          if(m_KeyDupliSetTimeout)--m_KeyDupliSetTimeout;
  25   2          if(m_TimerKeyMonitor)--m_TimerKeyMonitor;
  26   2          if(m_KeyDupli1stTimer)--m_KeyDupli1stTimer;
  27   2          else FG_d_StopKey=0;
  28   2          if  ( FG_d_StopKey &&m_KeyDupli1stTimer){
  29   3            time_led++;
  30   3            if(time_led>=90){time_led=0;PIN_LED=!PIN_LED;}
  31   3          }
  32   2          if(m_TimerKey)--m_TimerKey;
  33   2          
  34   2          if(TIME_BEEP_on)
  35   2          {
  36   3              //--TIME_BEEP_on;
  37   3              if(FG_beep_on==0)
  38   3              {
  39   4                  FG_beep_on=1;FG_beep_off=0;Beep_On();//BEEP_CSR2_BEEPEN=1; //2015.3.11修正
  40   4                  if(FG_LED_on)   PIN_LED=1;
  41   4              }
  42   3          }
  43   2          else if(TIME_BEEP_off)
  44   2          {
  45   3              //--TIME_BEEP_off;
  46   3              if(FG_beep_off==0)
  47   3              {
  48   4                  FG_beep_off=1;FG_beep_on=0;Beep_Off();//BEEP_CSR2_BEEPEN=0;  //2015.3.11修正
  49   4                  if(FG_LED_on)   PIN_LED=0;
  50   4              }
  51   3          }
  52   2          else if(TIME_BEEP_freq)
  53   2          {
  54   3              --TIME_BEEP_freq;
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 2   

  55   3              TIME_BEEP_on=BASE_TIME_BEEP_on;
  56   3              TIME_BEEP_off=BASE_TIME_BEEP_off;
  57   3              if(FG_beep_on==0)
  58   3              {
  59   4                  FG_beep_on=1;FG_beep_off=0;Beep_On();//BEEP_CSR2_BEEPEN=1;  //2015.3.11修正
  60   4                  if(FG_LED_on)PIN_LED=1;
  61   4              }      
  62   3          }
  63   2          else  FG_LED_on=0; 
  64   2          
  65   2      //    if(FG_BAT_value==0){START_AD_SAMPLER();FG_BAT_value=1;}
  66   2      //    else {ADC_read();FG_BAT_value=0;}
  67   2          _KeyInTx();
  68   2          if(FG_10s==1) return;   // 2015.1.31修正3
  69   2          _RegistrationMode();
  70   2          _DupliFuncSetMode();
  71   2          //ADC2_EOC_INT();
  72   2          ClearWDT(); // Service the WDT    
  73   2        }
  74   1      }
  75          
  76          
  77          void time_control(void)
  78          {
  79   1          if(FG_100ms){
  80   2              FG_100ms=0; 
  81   2              if(TIME_2s_RestTX)--TIME_2s_RestTX;    //2015.4.13修正    
  82   2              if(FG_PWRON==1){
  83   3                  if ((TB_5s)&&(m_KeyOptSetMode==0))  --TB_5s;
  84   3              }    
  85   2          }
  86   1          if(Time_Tx_Out == 0 && FLAG_APP_TX == 1)
  87   1          {
  88   2              FLAG_APP_TX = 0;
  89   2              if(FG_d_StopKey == 0)   PIN_TX_LED = 0;
  90   2              ML7345_SetAndGet_State(Force_TRX_OFF);
  91   2              ML7345_RESETN = 0;
  92   2              SpiGpio_UnInit();
  93   2              ML7345D_POWER = FG_NOT_allow_out;
  94   2          }
  95   1      }
  96          
  97          //
  98          /****************************************/
  99          /*                                                                              */
 100          /*                      Check Key for Tx                        */
 101          /*                                                                              */
 102          /*                        in  : none                            */
 103          /*                        out : none                            */
 104          /*                                                                              */
 105          /****************************************/
 106          //
 107          /*      Key data table  */
 108          //              ||||||||
 109          //              |||||||+ Auto Tx Stop
 110          //              ||||||++ Auto Tx Start
 111          //              |||||+++ Reg.
 112          //              ||||++++ Vent.
 113          //              |||+++++ Close
 114          //              ||++++++ Stop
 115          //              |+++++++ Open
 116          //              ++++++++ 1
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 3   

 117          //
 118          const   uchar   ct_KeyDataTable[]
 119          ={ 
 120                  /*      Reg. (0)        */
 121          0xFB,// 0b11111011,
 122          //      /*      Open (1)        */
 123          0xBF,// 0b10111111,
 124          //      /*      Stop (2)        */
 125          0xDF,// 0b11011111,
 126          //      /*      Close (3)       */
 127          0xEF,// 0b11101111,
 128          //      /*      Vent. (4)       */
 129          0xF7,// 0b11110111,
 130          //      /*      Open + Stop (5) */
 131          0x9F,// 0b10011111,
 132          //      /*      Open + Close (6)        */
 133          0xAF,// 0b10101111,
 134          //      /*      Open + Vent. (7)        */
 135          0xB7,// 0b10110111,
 136          //      /*      Open + Reg. (8) */
 137          0xBB,// 0b10111011,
 138          //      /*      Stop + Close (9)        */
 139          0xCF,// 0b11001111,
 140          //      /*      Stop + Reg. (10)        */
 141          0xDB,// 0b11011011,
 142          //      /*      Close + Reg. (11)       */
 143          0xEB,// 0b11101011,
 144          //      /*      Close + Vent. (12)      */
 145          0xE7,// 0b11100111,
 146          //      /*      Vent. + Reg. (13)       */
 147          0xF3,// 0b11110011,
 148          //      /*      Auto Tx start (14)      */
 149          0xFD,// 0b11111101,
 150          //      /*      Auto Tx stop (15)       */
 151          0xFE,// 0b11111110,
 152          //      /*      No push (16)    */
 153          0xFF,// 0b11111111,
 154          } ;
 155          
 156          //
 157          void    _KeyInTx( void )
 158          {
 159   1              idata uchar     i ;
 160   1              
 161   1              m_KindOfKey = d_Idle ;
 162   1              
 163   1              m_KeyNew = 0xFF ;
 164   1              if(BAT_out==2)return;
 165   1                      
 166   1              /*      Registration sw         */
 167   1              _SwIn( PIN_KEY_OPEN ) ;
 168   1              /*      Auto Tx Start sw                */
 169   1              _SwIn( PIN_KEY_STOP ) ;
 170   1              /*      Auto Tx Stop sw         */
 171   1              _SwIn( PIN_KEY_CLOSE ) ;
 172   1              /*      Auto Tx Vent. sw                */
 173   1              _SwIn( PIN_KEY_VENT ) ; 
 174   1              //_SwIn( 1 ) ;
 175   1              /*      Auto Tx Reg. sw         */
 176   1              _SwIn( PIN_KEY_LOGIN ) ;        
 177   1              /*      Auto Tx Auto Tx Start sw                */
 178   1              _SwIn( 1 ) ;    
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 4   

 179   1              /*      Auto TxAuto Tx Stop sw          */
 180   1              _SwIn( 1 ) ;    
 181   1              
 182   1              
 183   1              if      ( m_KeyNew != m_KeyOld )                                // Key in
 184   1              {                                                                                               // Different with the last state
 185   2                      m_KeyOld = m_KeyNew ;
 186   2                      _SetKeyChatterCount() ;                                         // Chatter counter set
 187   2                      _ClearSpecialMultiKeyState() ;                          // Clear key continue state
 188   2                      TIME_Once_twice_switch=5000;   //2015.1.31修正4
 189   2                      TIME_10s=10100;  //2015.1.31修正3
 190   2                      return ;
 191   2              }
 192   1              
 193   1              if      ( --m_ChatterCount )                                            // Chattering ok ?
 194   1              {
 195   2                      return ;
 196   2              }
 197   1              m_ChatterCount = 1 ;
 198   1              
 199   1              /*              For generate Batt. Low tone             */
 200   1              if      ( m_KeyNew != d_KeyNoPush )                     // Is key data no push ?
 201   1              {                                                                                               // No, any key push
 202   2      //              if      ( m_BattState )                                                 // Batt. Low ?
 203   2      //              {                                                                                       // Yes
 204   2      //                      _ReqBuzzer(d_BuzBattLow) ;                              // Request
 205   2      //              }
 206   2                  //if(BAT_value>1000){
 207   2                 if(TIME_Once_twice_switch)--TIME_Once_twice_switch;    //2015.1.31修正4
 208   2                 if(TIME_10s)--TIME_10s;    //2015.1.31修正3
 209   2                 //dd_set_ADF7021_Power_on_Init();
 210   2                 if((BAT_out==1)||(FG_BAT)||(TIME_10s==0)){   //2015.1.31修正3
 211   3                    if(FG_BAT==0){
 212   4                              FG_BAT=1;
 213   4                              if(TIME_10s==0){      //2015.1.31修正3
 214   5                                 BASE_TIME_BEEP_on=103;
 215   5                                 BASE_TIME_BEEP_off=103;
 216   5                              }
 217   4                              else {
 218   5                                 BASE_TIME_BEEP_on=40;
 219   5                                 BASE_TIME_BEEP_off=60;
 220   5                              }
 221   4                              TIME_BEEP_on=BASE_TIME_BEEP_on;
 222   4                              TIME_BEEP_off=BASE_TIME_BEEP_off;
 223   4                              TIME_BEEP_freq=2;       
 224   4                    }
 225   3                    else if(TIME_BEEP_freq<=1)TIME_BEEP_freq=2;
 226   3                  }
 227   2              }
 228   1                      
 229   1              /*              Search of valid key             */
 230   1              for     ( i=0; i<17;i++)
 231   1              {
 232   2                      if      ( m_KeyNew == ct_KeyDataTable[i] )      // Match ?
 233   2                      {
 234   3                              m_KeyNo = i ;
 235   3                              break ;                                                                 // Yes
 236   3                      }
 237   2              }
 238   1              key_Value=i;   // 2015.1.31修正3
 239   1              if(FG_10s==1)return;   // 2015.1.31修正3
 240   1              
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 5   

 241   1              if      ( i == 17)                      // Found ?
 242   1              {                                                                                               // No
 243   2                      mb_NoPush = d_Clear ;                                           // No push clear(Push on)
 244   2                      _ClearSpecialMultiKeyState() ;                          // Special multi key status clear
 245   2                      mb_NoPushWait = d_On ;                                          // Set no push wait
 246   2                      _DupliFuncClear() ;                                                     // Duplicate key function clear
 247   2                      return ;
 248   2              }
 249   1              
 250   1              if      ( mb_NoPushWait )                                                       // Wait for no push ?
 251   1              {                                                                                               // Yes
 252   2                      if      ( m_KeyNew != d_KeyNoPush )             // Is key data no push ?
 253   2                      {
 254   3                              if(((i==5)||(i==6)||(i==7)||(i==9)||(i==12))&&(FLAG_APP_TX==0));    //解决复数输出
             -，按键未松一直发送 
 255   3                              else return ;                                                           // No
 256   3                      }
 257   2              }
 258   1              
 259   1              switch  ( i )    // Jumo to key function
 260   1              {
 261   2                      case 0 :
 262   2                              _FuncReg();
 263   2                              break ;         
 264   2                      case 1 :
 265   2                      case 2 :  
 266   2                      case 3 : 
 267   2                      case 4 :   
 268   2                              if(FLAG_APP_TX==0)_FuncStop();   //2015.1.31修正4
 269   2                              break ; 
 270   2                      case 5 :  
 271   2                      case 6 :  
 272   2                      case 7 :  
 273   2                      case 9 :  
 274   2                      case 12 :  
 275   2                              _FuncOpenStop();
 276   2                              break ;         
 277   2                      case 8 :  
 278   2                              _FuncOpenReg();
 279   2                              break ;
 280   2                      case 10 :  
 281   2                              _FuncStopReg();
 282   2                              break ;
 283   2                      case 11 :  
 284   2                              _FuncCloseReg();
 285   2                              break ;
 286   2                      case 13 :  
 287   2                              _FuncVentReg();
 288   2                              break ;
 289   2                      case 14 :  
 290   2                              _FuncAutoTxStart();
 291   2                              break ;
 292   2                      case 15 :  
 293   2                              _FuncAutoTxStop();
 294   2                              break ;
 295   2                      case 16 :  
 296   2                              _FuncNoPush();
 297   2                              break ;
 298   2              }
 299   1      }
 300          /*----------------------------------*/
 301          /*                                                                      */
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 6   

 302          /*              Open + Stop(5) function         */
 303          /*              Open + Close(6) function        */
 304          /*              Open + Vent.(7) function        */
 305          /*              Stop + Close(9) function        */
 306          /*              Close + Vent.(12) function      */
 307          /*                                                                      */
 308          /*----------------------------------*/
 309          //
 310          void    _FuncOpenStop( void )
 311          {
 312   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 313   1              m_KindOfKey = d_Idle ;
 314   1              _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 315   1              _ClearSpecialMultiKeyState() ;                                  // Special multi key status clear
 316   1              mb_NoPush = d_Clear ;
 317   1              mb_NoPushWait = d_On ;
 318   1      }
 319          /*----------------------------------*/
 320          /*                                                                      */
 321          /*              Open + Reg. function            */
 322          /*                                                                      */
 323          /*----------------------------------*/
 324          //
 325          void    _FuncOpenReg( void )
 326          {
 327   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 328   1              mb_NoPush = d_Clear ;
 329   1              if      ( !mb_RegOpenSw )                                                       // Continue push ?
 330   1              {                                                                                               // No
 331   2                      mb_RegOpenSw = d_On ;
 332   2                      m_TimerKey = d_Time3s ; // Set 3sec key timer
 333   2                      if(FG_PWRON==0){
 334   3                         FG_PWRON=1;
 335   3                         PIN_POWER_CONTROL=1;
 336   3                         TB_5s=TB_60s;//60;  //5.1秒
 337   3                      }
 338   2                      return ;
 339   2              }
 340   1              
 341   1              _Pass3secKey( d_ReqOpenReg ) ;
 342   1      }
 343          /*----------------------------------*/
 344          /*                                                                      */
 345          /*              Close + Reg. function           */
 346          /*                                                                      */
 347          /*----------------------------------*/
 348          //
 349          void    _FuncCloseReg( void )
 350          {
 351   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 352   1              if      ( !mb_RegCloseSw )                                                      // Continue push ?
 353   1              {                                                                                               // No
 354   2                      mb_RegCloseSw = d_On ;
 355   2                      m_TimerKey = d_Time3s ;                                         // Set 3sec key timer
 356   2                      if(FG_PWRON==0){
 357   3                         FG_PWRON=1;
 358   3                         PIN_POWER_CONTROL=1;
 359   3                         TB_5s=TB_60s;//60;  //5.1秒
 360   3                      }
 361   2                      return ;
 362   2              }
 363   1              
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 7   

 364   1              _Pass3secKey( d_ReqCloseReg ) ;
 365   1      }
 366          /*----------------------------------*/
 367          /*                                                                      */
 368          /*              Vent. + Reg. function           */
 369          /*                                                                      */
 370          /*----------------------------------*/
 371          //
 372          void    _FuncVentReg( void )
 373          {
 374   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 375   1              if      ( !mb_RegVentSw )                                                       // Continue push ?
 376   1              {                                                                                               // No
 377   2                      mb_RegVentSw = d_On ;
 378   2                      m_TimerKey = d_Time3s ;                                         // Set 3sec key timer
 379   2                      if(FG_PWRON==0){
 380   3                         FG_PWRON=1;
 381   3                         PIN_POWER_CONTROL=1;
 382   3                         TB_5s=TB_60s;//60;  //5.1秒
 383   3                      }
 384   2                      return ;
 385   2              }
 386   1              
 387   1              _Pass3secKey( d_ReqVentReg ) ;
 388   1      }
 389          /*----------------------------------*/
 390          /*                                                                      */
 391          /*              Stop + Reg. function            */
 392          /*                                                                      */
 393          /*----------------------------------*/
 394          //
 395          void    _FuncStopReg( void )
 396          {
 397   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 398   1              if      ( !mb_RegStopSw )                                                       // Continue push ?
 399   1              {                                                                                               // No
 400   2                      mb_RegStopSw = d_On ;
 401   2                      m_TimerKey = d_Time3s ;                                         // Set 3sec key timer
 402   2                      if(FG_PWRON==0){
 403   3                         FG_PWRON=1;
 404   3                         PIN_POWER_CONTROL=1;
 405   3                         TB_5s=TB_60s;//60;  //5.1秒
 406   3                      }
 407   2                      return ;
 408   2              }
 409   1              
 410   1              _Pass3secKey( d_ReqStopReg ) ;
 411   1      }
 412          void    _Pass3secKey( uchar req )
 413          {
 414   1              if      ( m_TimerKey )                                                          // 3sec passed ?
 415   1              {
 416   2                      if      ( !--m_TimerKey )
 417   2                      {                                                                                       // Yes
 418   3                              _ReqTxdEdit( req,0 ) ;
 419   3                              FG_Complex_Single_shot=1;   //2015.1.31修正2
 420   3                              return ;
 421   3                      }
 422   2              }
 423   1      }
 424          /*------------------------------------------*/
 425          /*                                                                                      */
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 8   

 426          /*              Open/Stop/Close/Vent. function          */
 427          /*                                                                                      */
 428          /*------------------------------------------*/
 429          void    _FuncReg( void )
 430          {
 431   1              _DupliFuncClear() ;                                                             // Duplicate key function clear
 432   1              if      ( mb_NoPush )                                                           // No push before ?
 433   1              {                                                                                               // Yes
 434   2                      mb_NoPush = d_Clear ;
 435   2                      m_KindOfKey = d_RegKey ;
 436   2                      _ClearSpecialMultiKeyState() ;                          // Special multi key status clear
 437   2                      mb_RegSw = d_On ;
 438   2                      m_TimerKey = d_Time3s ;                                         // Set 3sec key timer
 439   2                      if      ( !m_TimerKeyMonitor )                                  // 1st entry ?
 440   2                      {       // Yes
 441   3                                if(FG_PWRON==0){
 442   4                                   FG_PWRON=1;
 443   4                                   PIN_POWER_CONTROL=1;
 444   4                                   TB_5s=51;//TB_51s;//51;  //5.1秒
 445   4                                }     
 446   3                              m_TimerKeyMonitor = d_Time10s ;                 // Set 10sec key timer
 447   3                              m_KeyCount = 2 ;
 448   3                              return ;
 449   3                      }
 450   2                      if      ( !--m_KeyCount )                                               // ID registration mode ?
 451   2                      {
 452   3                              _SetRegistrationMode( d_RegAppend ) ;
 453   3                              m_KindOfKey = d_Idle ;
 454   3                              mb_NoPushWait = d_On ;                                  // Set no push wait
 455   3                      }
 456   2                      return ;
 457   2              }
 458   1              
 459   1              /*              Reg.sw push             */
 460   1              if      ( mb_RegSw )                                                            // Continue push ?
 461   1              {                                                                                               // Yes
 462   2                      if      ( m_TimerKey )                                                  // 3sec passed ?
 463   2                      {
 464   3                              if      ( !--m_TimerKey )
 465   3                              {                                                                               // Yes
 466   4                                      _SetRegistrationMode( d_RegDelete ) ;   // ID delete mode set
 467   4                                      m_KindOfKey = d_Idle ;
 468   4                                      mb_NoPushWait = d_On ;                          // Set no push wait
 469   4                              }
 470   3                              return ;                                                                // No
 471   3                      }
 472   2              }  
 473   1      }
 474          void    _FuncStop( void )
 475          {
 476   1              if      ( _GetNoPushState() )                                           // No push before ?
 477   1              {                                                                                               // No
 478   2                      if      ( mb_OpenSw || mb_StopSw || mb_CloseSw )// Continue push ?
 479   2                      {                                                                                       // Yes
 480   3                              if      (( !m_TimerKey )&&(FG_BAT==0)&&(TIME_Once_twice_switch==0))  //2015.1.31修正4     // 5sec passed ?
 481   3                              {
 482   4      //                              if      ( !--m_TimerKey )
 483   4      //                              {                                                                       // Yes
 484   4                                              if      ( mb_OpenSw || mb_CloseSw )                             // Close sw ?
 485   4                                              {
 486   5                                                      m_KeyOptSetMode = 10 ;                          // Yes
 487   5                                                      //_ReqBuzzer( d_BuzOpt5 ) ;
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 9   

 488   5                                                      //_ReqBuzzer(103,103,100);
 489   5                                                      m_KindOfKey = d_Idle ;
 490   5                                                      mb_NoPushWait = d_On ;                  // Set no push wait
 491   5                                                      return ;
 492   5                                              }
 493   4                                              m_KeyOptSetMode = 1 ;                   // Opetion setting mode
 494   4                                              //_ReqBuzzer( d_BuzOpt1 ) ;
 495   4                                              _ReqBuzzer(103,103,1);
 496   4                                                      FG_LED_on=1;
 497   4                                                      if(FG_PWRON==0){
 498   5                                                          FG_PWRON=1;
 499   5                                                          PIN_POWER_CONTROL=1;
 500   5                                                          TB_5s=TB_51s;//51;  //5.1秒
 501   5                                                      }
 502   4                                              m_KeyDupliSetTimeout = d_DupliTime4s ;
 503   4                                              m_KindOfKey = d_Idle ;
 504   4                                              mb_NoPush=d_Off;
 505   4                                              mb_NoPushWait = d_On ;                  // Set no push wait
 506   4                                              m_KeyOptSetOpenStop = 1 ;
 507   4                                              if      ( mb_OpenSw )                           // Open ?
 508   4                                              {
 509   5                                                      m_KeyOptSetOpenStop = 0 ;       // Yes
 510   5                                              }
 511   4      //                              }
 512   4      //                              return ;                                                        // No
 513   4                              }
 514   3                              return ;
 515   3                      }
 516   2                      return ;
 517   2              }
 518   1              
 519   1              m_KindOfKey = m_KeyNo ;
 520   1              if      ( m_KeyOptSetMode ||m_RegMode)                                                  // Option setting mode ?
 521   1              {
 522   2                      return ;                                                                        // Yes
 523   2              }
 524   1              
 525   1              switch  ( m_KindOfKey )
 526   1              {
 527   2                      case d_OpenKey :
 528   2                              mb_OpenSw = d_On ;
 529   2                              m_TimerKey = d_Time5s ;                                 // Set 5sec key timer
 530   2                              break;
 531   2                              
 532   2                      case d_StopKey :
 533   2                              mb_StopSw = d_On ;
 534   2                              m_TimerKey = d_Time5s ;                                 // Set 5sec key timer
 535   2                              break;
 536   2                              
 537   2                      case d_CloseKey :
 538   2                              mb_CloseSw = d_On ;
 539   2                              m_TimerKey = d_Time5s ;//d_Time9s ;                                     // Set 5sec key timer
 540   2                              break;
 541   2              }
 542   1              
 543   1                /********2015.1.31追加  按一次模式********/
 544   1              if      ( !rom_KeyOpt || m_KindOfKey == d_VentKey  )// Single push option or Vent. key ?
 545   1              
 546   1      //          /********2015.1.31追加  按2次模式********/
 547   1      //      if      ( rom_KeyOpt || m_KindOfKey == d_VentKey  )// Single push option or Vent. key ?        
 548   1              {                                                                                               // Yes
 549   2                      _DupliFuncClear() ;                                                     // Duplicate key function clear
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 10  

 550   2                      _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 551   2                      m_TimerKeyMonitor = d_Clear ;
 552   2                      return ;
 553   2              }
 554   1              
 555   1              /*      Multi push option       */
 556   1              if      ( m_KeyOptSetMode || m_RegMode )
 557   1              {
 558   2                      return ;
 559   2              }
 560   1              
 561   1              if      ( m_KindOfKey == d_StopKey )
 562   1              {
 563   2                      _DupliFuncClear() ;                                                     // Duplicate key function clear
 564   2                      _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 565   2                      m_TimerKeyMonitor = d_Clear ;
 566   2                      FG_d_StopKey=1;
 567   2                      m_KeyDupli1stTimer = d_D1stTime3s ;
 568   2                      time_led=0;
 569   2                      return ;
 570   2              }
 571   1              
 572   1              switch  ( m_KindOfKey )
 573   1              {
 574   2      //              case d_OpenKey :
 575   2      //                      m_KeyCloseCount = 2 ;
 576   2      //                      if      ( !--m_KeyOpenCount )
 577   2      //                      {
 578   2      //                              _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 579   2      //                              m_TimerKeyMonitor = d_Clear ;
 580   2      //                              _DupliFuncClear() ;                                     // Duplicate key function clear
 581   2      //                              return ;
 582   2      //                      }
 583   2      //                      m_KeyDupli1stTimer = d_D1stTime3s ;
 584   2      //                      break;
 585   2      //                      
 586   2      //              case d_CloseKey :
 587   2      //                      m_KeyOpenCount = 2 ;
 588   2      //                      if      ( !--m_KeyCloseCount )
 589   2      //                      {
 590   2      //                              _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 591   2      //                              m_TimerKeyMonitor = d_Clear ;
 592   2      //                              _DupliFuncClear() ;                                     // Duplicate key function clear
 593   2      //                              return ;
 594   2      //                      }
 595   2      //                      m_KeyDupli1stTimer = d_D1stTime3s ;
 596   2      //                      break;
 597   2                
 598   2                      case d_OpenKey :
 599   2                      case d_CloseKey :  
 600   2                              if      ( FG_d_StopKey && m_KeyDupli1stTimer)
 601   2                              {
 602   3                                      FG_d_StopKey=0;
 603   3                                      m_KeyDupli1stTimer=0;
 604   3                                      _ReqTxdEdit( m_KeyNo,m_KeyNo ) ;
 605   3                                      m_TimerKeyMonitor = d_Clear ;
 606   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 607   3                                      return ;
 608   3                              }
 609   2                              break;
 610   2                                              
 611   2              }  
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 11  

 612   1      }
 613          
 614          void    _FuncAutoTxStart( void )
 615          {
 616   1        
 617   1      }
 618          void    _FuncAutoTxStop( void )
 619          {
 620   1        
 621   1      }
 622          void    _FuncNoPush( void )
 623          {
 624   1              mb_OpenSw = d_Off ;                                                     // For duplicate keyvfunction
 625   1              mb_StopSw = d_Off ;
 626   1              mb_CloseSw = d_Off ;
 627   1              FG_BAT=0;
 628   1              
 629   1              _ClearSpecialMultiKeyState() ;                          // Special multi key status clear
 630   1              mb_NoPush     = d_On ;                                          // No push on
 631   1              mb_NoPushWait = d_Off ;                                         // No push wait clear
 632   1              m_KindOfKey = d_KeyNoPush;//d_NoPushKey ;
 633   1      //      if      ( m_BuzzerMode == d_BuzBattLow )                        // Batt.Low sound out ?
 634   1      //      {
 635   1      //              _BuzIdle() ;
 636   1      //      }  
 637   1      }
 638          void    _SetKeyChatterCount( void )
 639          {
 640   1              m_ChatterCount = d_Time50ms ;                                           // Chatter counter set
 641   1              m_TimerKey = 0 ;
 642   1      }
 643          /*==============================================*/
 644          /*                                                                                              */
 645          /*              Clear special multi key push status             */
 646          /*                                                                                              */
 647          /*                       in  : none                                                     */
 648          /*                       out : none                                                     */
 649          /*                                                                                              */
 650          /*==============================================*/
 651          //
 652          void    _ClearSpecialMultiKeyState( void )
 653          {
 654   1              mb_RegSw      = d_Clear ;
 655   1              mb_RegStopSw  = d_Clear ;
 656   1              mb_RegOpenSw  = d_Clear ;
 657   1              mb_RegCloseSw = d_Clear ;
 658   1              mb_RegVentSw  = d_Clear ;
 659   1      }
 660          /****************************************/
 661          /*                                                                              */
 662          /*              Key duplicate function clear    */
 663          /*                                                                              */
 664          /*                        in  : none                            */
 665          /*                        out : none                            */
 666          /*                                                                              */
 667          /****************************************/
 668          //
 669          void    _DupliFuncClear( void )
 670          {
 671   1              m_KeyOptSetMode = d_Idle ;
 672   1              m_KeyOpenCount = 2 ;
 673   1              m_KeyCloseCount = 2 ;
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 12  

 674   1              //mb_OpenSw = d_Off ;
 675   1              //mb_StopSw = d_Off ;
 676   1              if      ( m_KeyDupli1stTimer )
 677   1              {
 678   2                      m_KeyDupli1stTimer = d_Clear ;
 679   2                      //_LedOnOff( d_LedOff ) ;                               // Led off
 680   2              }
 681   1      }
 682          /*==============================================*/
 683          /*                                                                                              */
 684          /*                      No Push(Last time) check                        */
 685          /*                                                                                              */
 686          /*                       in  : none                                                     */
 687          /*                       out : 0: No push                                       */
 688          /*                                 1: any push                                  */
 689          /*                                                                                              */
 690          /*==============================================*/
 691          //
 692          u8 _GetNoPushState(void)
 693          {
 694   1              if      (!mb_NoPush)                                                            // No push before ?
 695   1              {                                                                                               // No
 696   2                      return(d_NG) ;
 697   2              }
 698   1              
 699   1              mb_NoPush = d_Clear ;
 700   1      //      /*              Set Auto Tx inhibit             */
 701   1      //      mb_AutoTxInhibit = d_On ;                               // Inhibit
 702   1      //      mb_AutoTxOnOff   = d_Off ;                              // Off
 703   1      //      
 704   1              m_TimerKey = d_Clear ;
 705   1              _ClearSpecialMultiKeyState() ;                                  // Special multi key status clear
 706   1              return(d_OK) ;
 707   1      }
 708          
 709          void _ReqTxdEdit(u8 txreq ,u8 buzreq )  // Tx data edit request
 710          {
 711   1          u8 time_key;
 712   1          if((TB_sum_5s<69)&&(FG_PWRON==1)&&(TB_5s<25))
 713   1          {      //计算剩余的时间，总共时间不能超过69，以25为间隔。
 714   2              time_key=25-TB_5s;
 715   2              TB_sum_5s=TB_sum_5s+time_key;
 716   2              if((69-TB_sum_5s)>=27)  TB_5s=25;
 717   2          }
 718   1          if((TB_5s>=25)||(TIME_2s_RestTX==0))
 719   1          {   //2015.4.13修正
 720   2              if(FG_PWRON==0)
 721   2              {
 722   3                  FG_PWRON=1;
 723   3                  PIN_POWER_CONTROL=1;
 724   3                  TB_5s=TB_51s;//51;  //5.1秒
 725   3              }
 726   2              switch  ( txreq )    // Jumo to key function
 727   2              {
 728   3                  case 1 :
 729   3                          Control_code=0x08;     //open
 730   3                      break ;
 731   3                  case 2 :    
 732   3                          Control_code=0x04;    //stop
 733   3                      break ;
 734   3                  case 3 :    
 735   3                          Control_code=0x02;    //close
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 13  

 736   3                      break ;
 737   3                  case 4 :    
 738   3                          Control_code=0x01;    //vnet 换气
 739   3                      break ;
 740   3                  case 10 :                 //Stop + Reg
 741   3                          Control_code=0x14;
 742   3                      break ; 
 743   3                  case 5 :                      //Open + Stop    
 744   3                          Control_code=0x0C;
 745   3                          break ;     
 746   3                  case 6 :                   //Open + Close
 747   3                         Control_code=0x0A;
 748   3                          break ;     
 749   3                  case 7 :                   //Open + Vent
 750   3                         Control_code=0x09;
 751   3                          break ;     
 752   3                  case 9 :                //Stop + Close
 753   3                         Control_code=0x06;
 754   3                          break ;     
 755   3                  case 12 :              //Close + Vent.
 756   3                         Control_code=0x03;
 757   3                          break ;     
 758   3              }
 759   2              switch  ( buzreq )    // Jumo to key function
 760   2              {
 761   3                  case 1 :
 762   3                         _ReqBuzzer(103,103,0);
 763   3          //                  BASE_TIME_BEEP_on=103;
 764   3          //                        BASE_TIME_BEEP_off=103;
 765   3          //                  TIME_BEEP_freq=0;
 766   3                      break ;
 767   3                  case 2 :
 768   3                         _ReqBuzzer(103,103,1);
 769   3          //                  BASE_TIME_BEEP_on=103;
 770   3          //                        BASE_TIME_BEEP_off=103;
 771   3          //                  TIME_BEEP_freq=1;
 772   3                      break ;
 773   3                  case 3 :    
 774   3                        _ReqBuzzer(103,103,2);
 775   3          //                  BASE_TIME_BEEP_on=103;
 776   3          //                        BASE_TIME_BEEP_off=103;
 777   3          //                  TIME_BEEP_freq=2;
 778   3                      break ;
 779   3                  case 4 :    
 780   3                        _ReqBuzzer(500,10,0);
 781   3                        break ;
 782   3                  case 20 :   
 783   3                         _ReqBuzzer(1000,10,0);
 784   3          //                  BASE_TIME_BEEP_on=1000;
 785   3          //                        BASE_TIME_BEEP_off=1;
 786   3          //                  TIME_BEEP_freq=0;
 787   3                      break ;
 788   3              }       
 789   2              dd_set_ML7345D_Power_on();
 790   2              PROFILE_CH_FREQ_32bit_200002EC = 426075000;
 791   2              RF_ML7345_Init(Fre_426_075,0x15,12);    
 792   2              SendTxData();
 793   2              TIME_2s_RestTX = 25;       //2015.4.13修正        
 794   2        }
 795   1        else PIN_LED=0;
 796   1      }
 797          
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 14  

 798          //
 799          /************************************************/
 800          /*                                                                                              */
 801          /*              Key duplicate function setting mode             */
 802          /*                              Every 10ms                                              */
 803          /*                                                                                              */
 804          /*                        in  : none                                            */
 805          /*                        out : none                                            */
 806          /*                                                                                              */
 807          /************************************************/
 808          //
 809          void    _DupliFuncSetMode( void )
 810          {
 811   1        u8 m_KeyOpt;
 812   1              switch  ( m_KeyOptSetMode )
 813   1              {
 814   2                      case 1 :
 815   2                              if      ( !mb_NoPushWait )                                      // No push ?
 816   2                              {
 817   3                                      m_KeyDupliSetTimeout = d_DupliTime1s ;  // Yes
 818   3                                      ++m_KeyOptSetMode ;
 819   3                                      return ;
 820   3                              }
 821   2                              if      ( !m_KeyDupliSetTimeout )                       // Pushing 9s over ?
 822   2                              {
 823   3                                      m_KeyOptSetMode = 10 ;                          // Yes
 824   3                                      //_ReqBuzzer( d_BuzOpt5 ) ;
 825   3                                      //_ReqBuzzer(103,103,100);
 826   3                                      
 827   3                              }
 828   2                              break ;
 829   2                              
 830   2                      case 2 :
 831   2                              if      ( !m_KeyDupliSetTimeout )                       // Wait 1s ok ?
 832   2                              {                                                                               // Yes
 833   3                                      ++m_KeyOptSetMode;
 834   3                                      m_KeyDupliSetTimeout = d_DupliTime3s ;
 835   3                                      //_ReqBuzzer( d_BuzOpt2 ) ;
 836   3                                      _ReqBuzzer(103,103,0);
 837   3                                      FG_LED_on=1;
 838   3                              }
 839   2                              
 840   2                              if      ( m_KindOfKey != d_Idle && m_KindOfKey != d_KeyNoPush )
 841   2                              {
 842   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 843   3                              }
 844   2                              break ;
 845   2                              
 846   2                      case 3 :                                                                        // Sw in wait
 847   2                              if      ( !m_KeyDupliSetTimeout )
 848   2                              {
 849   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 850   3                                      return ;
 851   3                              }
 852   2                              
 853   2                              if      ( m_KindOfKey == d_Idle || m_KindOfKey == d_KeyNoPush )
 854   2                              {
 855   3                                      return ;
 856   3                              }
 857   2                              
 858   2                              if      ( m_KeyOptSetOpenStop )                         // Setting by stop ?
 859   2                              {                                                                               // Yes
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 15  

 860   3                                      if      ( m_KindOfKey == d_StopKey )
 861   3                                      {
 862   4                                              m_KeyDupliSetTimeout = d_DupliTime1s ;
 863   4                                              ++m_KeyOptSetMode ;
 864   4                                              //mb_NoPushWait = d_On ;
 865   4                                      }
 866   3                                      else
 867   3                                      {                                                                       // Error
 868   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 869   4                                              return ;
 870   4                                      }
 871   3                              }
 872   2                              else
 873   2                              {
 874   3                                      if      ( m_KindOfKey == d_OpenKey )
 875   3                                      {
 876   4                                              m_KeyDupliSetTimeout = d_DupliTime1s ;
 877   4                                              ++m_KeyOptSetMode ;
 878   4                                              
 879   4                                      }
 880   3                                      else
 881   3                                      {                                                                       // Error
 882   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 883   4                                              return ;
 884   4                                      }
 885   3                              }
 886   2                              break ;
 887   2                              
 888   2                      case 4 :
 889   2                              if      ( !m_KeyDupliSetTimeout )                       // Wait 1s ok ?
 890   2                              {                                                                               // Yes
 891   3                                      ++m_KeyOptSetMode ;
 892   3                                      m_KeyDupliSetTimeout = d_DupliTime3s ;
 893   3                                      //_ReqBuzzer( d_BuzOpt2 ) ;
 894   3                                      _ReqBuzzer(103,103,0);
 895   3                                      FG_LED_on=1;
 896   3                              }
 897   2      //                      
 898   2      //                      if      ( m_KindOfKey != d_Idle && m_KindOfKey != d_KeyNoPush  )
 899   2      //                      {                                                                               // Error
 900   2      //                              _DupliFuncClear() ;                                     // Duplicate key function clear
 901   2      //                      }
 902   2                              break ;
 903   2                              
 904   2                      case 5 :                                                                        // Sw in wait
 905   2                              if      ( !m_KeyDupliSetTimeout )
 906   2                              {
 907   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 908   3                                      return ;
 909   3                              }
 910   2                              
 911   2                              if      ( m_KindOfKey == d_Idle || m_KindOfKey == d_KeyNoPush )
 912   2                              {
 913   3                                      return ;
 914   3                              }
 915   2                              
 916   2                              if      ( m_KeyOptSetOpenStop )                         // Setting by stop ?
 917   2                              {                                                                               // Yes
 918   3                                      if      ( m_KindOfKey == d_StopKey )
 919   3                                      {
 920   4                                              m_KeyDupliSetTimeout = d_DupliTime1s ;
 921   4                                              ++m_KeyOptSetMode ;
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 16  

 922   4                                              mb_NoPushWait = d_On ;
 923   4                                      }
 924   3                                      else
 925   3                                      {                                                                       // Error
 926   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 927   4                                              return ;
 928   4                                      }
 929   3                              }
 930   2                              else
 931   2                              {
 932   3                                      if      ( m_KindOfKey == d_OpenKey )
 933   3                                      {
 934   4                                              m_KeyDupliSetTimeout = d_DupliTime1s ;
 935   4                                              ++m_KeyOptSetMode ;
 936   4                                      }
 937   3                                      else
 938   3                                      {                                                                       // Error
 939   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 940   4                                              return ;
 941   4                                      }
 942   3                              }
 943   2                              break ;
 944   2                              
 945   2                      case 6 :
 946   2                              if      ( !m_KeyDupliSetTimeout )                       // Wait 1s ok ?
 947   2                              {                                                                               // Yes
 948   3                                      ++m_KeyOptSetMode ;
 949   3                                      m_KeyDupliSetTimeout = d_DupliTime3s ;
 950   3                                      //_ReqBuzzer( d_BuzOpt3 ) ;
 951   3                                      _ReqBuzzer(103,103,2);
 952   3                                      FG_LED_on=1;                            
 953   3                              }
 954   2                              
 955   2      //                      if      ( m_KindOfKey != d_Idle && m_KindOfKey != d_KeyNoPush )
 956   2      //                      {                                                                               // Error
 957   2      //                              _DupliFuncClear() ;                                     // Duplicate key function clear
 958   2      //                      }
 959   2                              break ;
 960   2                              
 961   2                      case 7 :                                                                        // Sw in wait
 962   2                              if      ( !m_KeyDupliSetTimeout )
 963   2                              {
 964   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
 965   3                                      return ;
 966   3                              }
 967   2                              
 968   2                              if      ( m_KindOfKey == d_Idle || m_KindOfKey == d_KeyNoPush )
 969   2                              {
 970   3                                      return ;
 971   3                              }
 972   2                              
 973   2                              if      ( m_KeyOptSetOpenStop )                         // Setting by stop ?
 974   2                              {                                                                               // Yes
 975   3                                      if      ( m_KindOfKey == d_StopKey )
 976   3                                      {
 977   4                                              m_KeyDupliSetTimeout = d_DupliTime10s ;
 978   4                                              ++m_KeyOptSetMode ;
 979   4                                              mb_NoPushWait = d_On ;
 980   4                                      }
 981   3                                      else
 982   3                                      {                                                                       // Error
 983   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 17  

 984   4                                              return ;
 985   4                                      }
 986   3                              }
 987   2                              else
 988   2                              {
 989   3                                      if      ( m_KindOfKey == d_OpenKey )
 990   3                                      {
 991   4                                              m_KeyDupliSetTimeout = d_DupliTime10s ;
 992   4                                              ++m_KeyOptSetMode ;
 993   4                                      }
 994   3                                      else
 995   3                                      {                                                                       // Error
 996   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
 997   4                                              return ;
 998   4                                      }
 999   3                              }
1000   2                              break ;
1001   2                              
1002   2                      case 8 :                                                                        // Sw in wait
1003   2                      case 9 :                                                                        // Sw in wait
1004   2                              if      ( !m_KeyDupliSetTimeout )
1005   2                              {
1006   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
1007   3                                      return ;
1008   3                              }
1009   2                              
1010   2                              if      ( m_KindOfKey == d_Idle || m_KindOfKey == d_KeyNoPush )
1011   2                              {
1012   3                                      return ;
1013   3                              }
1014   2                              
1015   2                              if      ( m_KeyOptSetOpenStop )                         // Setting by stop ?
1016   2                              {                                                                               // Yes
1017   3                                      if      ( m_KindOfKey == d_StopKey )
1018   3                                      {
1019   4                                              if      ( m_KeyOptSetMode == 9 )
1020   4                                              {
1021   5                                                      m_KeyOpt = rom_KeyOpt ;
1022   5                                                      if      ( m_KeyOpt )
1023   5                                                      {
1024   6                                                              m_KeyOpt = 0 ;
1025   6                                                      }
1026   5                                                      else
1027   5                                                      {
1028   6                                                              m_KeyOpt = 1 ;
1029   6                                                      }
1030   5                                                      rom_KeyOpt = m_KeyOpt;
1031   5                              IAP_WriteBuf_With_Protect_Verify(addr_eeprom_sys+Addr_rom_KeyOpt,&rom_KeyOpt,1);
1032   5                                                      //KeyOpt_EEPROM_write();
1033   5                                                      //_FlashWriteID() ;                             // Write data to flash rom
1034   5                                                      
1035   5                                                      //_ReqBuzzer( d_BuzOpt4 ) ;
1036   5                                                      _ReqBuzzer(103,103,4);
1037   5                                                      FG_LED_on=1;    
1038   5                                                      FG_d_StopKey=0;
1039   5                                                      TB_5s=TB_20s;//20;
1040   5                                                      _DupliFuncClear() ;                             // Duplicate key function clear
1041   5                                                      return ;
1042   5                                              }
1043   4                                              ++m_KeyOptSetMode ;
1044   4                                      }
1045   3                                      else
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 18  

1046   3                                      {                                                                       // Error
1047   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
1048   4                                              return ;
1049   4                                      }
1050   3                              }
1051   2                              else
1052   2                              {
1053   3                                      if      ( m_KindOfKey == d_OpenKey )
1054   3                                      {
1055   4                                              if      ( m_KeyOptSetMode == 9 )
1056   4                                              {
1057   5                                                      m_KeyOpt = rom_KeyOpt ;
1058   5                                                      if      ( m_KeyOpt )
1059   5                                                      {
1060   6                                                              m_KeyOpt = 0 ;
1061   6                                                      }
1062   5                                                      else
1063   5                                                      {
1064   6                                                              m_KeyOpt = 1 ;
1065   6                                                      }
1066   5                                                      rom_KeyOpt=m_KeyOpt;
1067   5                              IAP_WriteBuf_With_Protect_Verify(addr_eeprom_sys+Addr_rom_KeyOpt,&rom_KeyOpt,1);
1068   5                                                      //KeyOpt_EEPROM_write();                                // Write data to flash rom
1069   5                                                      
1070   5                                                      //_ReqBuzzer( d_BuzOpt4 ) ;
1071   5                                                      _ReqBuzzer(103,103,4);
1072   5                                                      FG_LED_on=1;
1073   5                                                      FG_d_StopKey=0;
1074   5                                                      _DupliFuncClear() ;                             // Duplicate key function clear
1075   5                                                      
1076   5                                                      return ;
1077   5                                              }
1078   4                                              ++m_KeyOptSetMode ;
1079   4                                      }
1080   3                                      else
1081   3                                      {                                                                       // Error
1082   4                                              _DupliFuncClear() ;                             // Duplicate key function clear
1083   4                                              return ;
1084   4                                      }
1085   3                              }
1086   2                              break ;
1087   2                              
1088   2                      case 10 :
1089   2                              if      ( !mb_NoPushWait )                                      // No push ?
1090   2                              {
1091   3                                      //_BuzIdle() ;
1092   3                                      _DupliFuncClear() ;                                     // Duplicate key function clear
1093   3                                      return ;
1094   3                              }
1095   2                              break ;
1096   2                              
1097   2              }
1098   1      }
1099          /****************************************/
1100          /*                                                                              */
1101          /*              Registration mode procedure             */
1102          /*                                                                              */
1103          /*                        in  : none                            */
1104          /*                        out : none                            */
1105          /*                                                                              */
1106          /****************************************/
1107          //
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 19  

1108          void    _RegistrationMode( void )
1109          {
1110   1              if      ( !_GetRegMode() )                                                      // Reg. mode Idle ?
1111   1              {                                                                                               // Yes
1112   2                      return ;
1113   2              }
1114   1      
1115   1              if(FG_PWRON==0){
1116   2              FG_PWRON=1;
1117   2              PIN_POWER_CONTROL=1;
1118   2              }       
1119   1              if(m_TimerRegMode){
1120   2                TB_5s=51;//TB_51s;//51;  //5.1秒
1121   2                time_led++;
1122   2                if(time_led>=500){time_led=0;PIN_LED=!PIN_LED;}         
1123   2              }
1124   1              else {
1125   2                      //_ReqBuzzer(500,250,3);
1126   2                      _ReqBuzzer(500,250,2);
1127   2                      PIN_LED=0;
1128   2                      m_RegMode = d_Idle ;
1129   2              }
1130   1              /*      Led control     */
1131   1      //      if      ( mb_LedOnOff )                                                         // Led on timing ?
1132   1      //      {                                                                                               // Yes
1133   1      //              _LedOnOff( d_LedOn ) ;                                          // Led on
1134   1      //      }
1135   1      //      else
1136   1      //      {
1137   1      //              _LedOnOff( d_LedOff ) ;                                         // Led off
1138   1      //      }
1139   1              
1140   1              switch  ( m_KindOfKey )
1141   1              {
1142   2                      case    d_OpenKey :
1143   2                              if      ( ++m_RegID[m_RegDigit] > '9' )         // No. up
1144   2                              {
1145   3                                      m_RegID[m_RegDigit] = '0' ;
1146   3                              }
1147   2                              //_ReqBuzzer(d_BuzOpen) ;
1148   2                              _ReqBuzzer(103,103,0);
1149   2                              m_TimerRegMode = d_Time1min ;                   // 1min. set (1s base)
1150   2                              break ;
1151   2                              
1152   2                      case    d_StopKey :                                             // Next digit
1153   2                              if      ( ++m_RegDigit > 8 )
1154   2                              {
1155   3                                      m_RegDigit= 8 ;
1156   3                              }
1157   2      /*              Add on 2007/5/28                */
1158   2                              else
1159   2                              {
1160   3                                      //_ReqBuzzer(d_BuzStop) ;
1161   3                                _ReqBuzzer(103,103,1);
1162   3                              }
1163   2      /*********************************/
1164   2      /*              Deleted on 2007/5/28            */
1165   2      //                      _ReqBuzzer(d_BuzStop) ;
1166   2      /*********************************/
1167   2                              m_TimerRegMode = d_Time1min ;                   // 1min. set (1s base)
1168   2                              break ;
1169   2                              
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 20  

1170   2                      case    d_CloseKey :
1171   2                              _IdClear() ;                                                    // ID clear
1172   2                              //_ReqBuzzer(d_BuzReg) ;
1173   2                              _ReqBuzzer(1000,10,0);
1174   2                              m_TimerRegMode = d_Time1min ;                   // 1min. set (1s base)
1175   2                              break ;
1176   2                              
1177   2                      case    d_RegKey :                                              // Send ID
1178   2      /*              Add on 2007/5/28                */
1179   2                              if      ( m_RegDigit < 8 )
1180   2                              {
1181   3                                      return ;
1182   3                              }
1183   2      /*********************************/
1184   2      
1185   2                              //_SetRegModeIdle() ;
1186   2                              //m_RegMode = d_Idle ;
1187   2                              ID_data_add.IDC = (ulong)atol(m_RegID) ;
1188   2      /*              Modified on 2007/5/28           */
1189   2      //                      if      ( m_RFID.ID > 16777215 )                        // Over ?
1190   2                              if      ( ID_data_add.IDC > 16777214 )                  // Over ?
1191   2      /*********************************/
1192   2                              {
1193   3                                      //_ReqBuzzer(d_BuzRegEnd) ;
1194   3                                      _ReqBuzzer(100,100,3);            
1195   3                              }
1196   2                              else
1197   2                              {
1198   3                                      _ReqTxdEdit(20,20) ;
1199   3                                    
1200   3                              }
1201   2                              m_RegMode = d_Idle ;
1202   2                              break ;
1203   2              }
1204   1      }
1205          //
1206          
1207          
1208          
1209          u32 atol (unsigned char* m_RegID_x)
1210          {
1211   1        u8 i,j;
1212   1        u32 m_ID=0;
1213   1          
1214   1        for(i=0;i<8;i++){
1215   2          j=m_RegID_x[i]-'0';
1216   2          m_ID=m_ID*10+j;
1217   2        }
1218   1        return(m_ID);
1219   1      }
1220          
1221          
1222          /************************************************/
1223          /*                                                                                              */
1224          /*                              Set registration mode                   */
1225          /*                                                                                              */
1226          /*              in  : mode( 0:Idle/1:Append/2:Delete )  */
1227          /*              out : none                                                              */
1228          /*                                                                                              */
1229          /************************************************/
1230          //
1231          void    _SetRegistrationMode( uchar mode )
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 21  

1232          {
1233   1              if      (_GetRegMode())                                                 // Reg. mode Idle ?
1234   1              {                                                                                               // No
1235   2                      return ;
1236   2              }
1237   1              
1238   1              m_RegMode = mode ;
1239   1      //      m_RFAddDelCode = 0x00 ;                                         // Set delete
1240   1      //      if      ( m_RegMode == d_RegAppend )                    // Append ?
1241   1      //      {                                                                                       // Yes
1242   1      //              m_RFAddDelCode = 0xFF ;                                 // Set Append
1243   1      //      }
1244   1              
1245   1              _IdClear() ;                                                            // ID clear
1246   1              
1247   1      //      _LedOnOff( d_LedOn ) ;                                          // Led on
1248   1      //      m_BlkTimer = d_Time500ms ;                                      // Blink start
1249   1      //      mb_LedOnOff = d_On ;
1250   1      //      
1251   1      //      _ReqBuzzer(d_BuzReg) ;
1252   1              _ReqBuzzer(1000,10,0);
1253   1              m_TimerRegMode = d_Time1min ;                           // 1min. set (1s base)
1254   1      }
1255          u8 _GetRegMode(void)
1256          {
1257   1              return(m_RegMode) ;
1258   1      }
1259          /********************************************/
1260          /*                                                                                      */
1261          /*                                      ID clear                                */
1262          /*                                                                                      */
1263          /********************************************/
1264          //
1265          void _IdClear(void)
1266          {
1267   1              register        uchar   i ;
1268   1              
1269   1              m_RegDigit = 0 ;                                                        // Digit pointer clear
1270   1              //m_RFID.ID  = 0 ;                                                      // ID Number clear
1271   1              for     ( i=0; i<8; i++ )                                               // ID clear
1272   1              {
1273   2                      m_RegID[i] = '0' ;
1274   2              }
1275   1              m_RegID[8] = 0 ;                                                        // NULL set
1276   1              
1277   1      }
1278          
1279          //
1280          /*--------------------------------------*/
1281          /*                                      */
1282          /*                      Sw data input   */
1283          /*                                      */
1284          /*                        in  : sw      */
1285          /*                        out : none    */
1286          /*                                      */
1287          /*--------------------------------------*/
1288          //
1289          void _SwIn(u8 sw)
1290          {
1291   1              m_KeyNew<<= 1 ;
1292   1              if      ( sw )
1293   1              {
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 22  

1294   2                      m_KeyNew |= d_On ;
1295   2              }
1296   1      }
1297          
1298          void _ReqBuzzer(u16 BEEP_on_SET,u8 BEEP_off_SET,u8 BEEP_freq_SET)
1299          {
1300   1          if(FG_BAT==0)
1301   1          {
1302   2              BASE_TIME_BEEP_on=BEEP_on_SET;
1303   2              BASE_TIME_BEEP_off=BEEP_off_SET;
1304   2              TIME_BEEP_on=BASE_TIME_BEEP_on;
1305   2              TIME_BEEP_off=BASE_TIME_BEEP_off;
1306   2              TIME_BEEP_freq=BEEP_freq_SET;
1307   2          }
1308   1      }
1309          
1310          void test_mode_control(void)
1311          {
1312   1      
1313   1          while(PIN_test_mode == 0)
1314   1          { 
1315   2              if(Flag_test_mode == 0)
1316   2                      {
1317   3                              Flag_test_mode = 1;
1318   3                              PIN_POWER_CONTROL = 1;
1319   3                  PIN_TX_LED = 1;
1320   3                              Init_Uart0_T1(); 
1321   3                  INT_EnAll(); 
1322   3                  Beep_On();
1323   3                  TIME_BEEP_off = 200;            
1324   3                  while(TIME_BEEP_off);
1325   3                  Beep_Off();
1326   3                      }
1327   2              ClearWDT(); // Service the WDT 
1328   2              if((PIN_KEY_OPEN==0)&&(FG_KEY_OPEN==0))
1329   2              {
1330   3                  FG_KEY_OPEN = 1;
1331   3                  dd_set_ML7345D_Power_on();
1332   3                  PROFILE_CH_FREQ_32bit_200002EC = 426075000;
1333   3                  RF_ML7345_Init(Fre_426_075,0x15,12);
1334   3                  FG_test_mode = 0;
1335   3                  Tx_Data_Test(0);
1336   3              }
1337   2              if(PIN_KEY_OPEN == 1) FG_KEY_OPEN = 0;
1338   2      
1339   2              if((PIN_KEY_STOP == 0)&&(FG_KEY_STOP == 0))
1340   2              {
1341   3                  FG_KEY_STOP = 1;
1342   3                  ML7345_RESETN = 0;
1343   3                  SpiGpio_UnInit(); 
1344   3                  ML7345D_POWER = FG_NOT_allow_out;
1345   3                  FG_test_mode = 0;
1346   3              }
1347   2              if(PIN_KEY_STOP == 1)   FG_KEY_STOP = 0; 
1348   2      
1349   2              if((PIN_KEY_CLOSE == 0) && (FG_KEY_CLOSE == 0))
1350   2              {
1351   3                  FG_KEY_CLOSE = 1;
1352   3                  dd_set_ML7345D_Power_on();
1353   3                  PROFILE_CH_FREQ_32bit_200002EC = 426075000;
1354   3                  RF_ML7345_Init(Fre_426_075,0x15,12);
1355   3                  Tx_Data_Test(1);
C51 COMPILER V9.60.0.0   KEY_AND_OTHER                                                     03/28/2022 17:48:08 PAGE 23  

1356   3                  FG_test_mode = 1;
1357   3              }
1358   2              if(PIN_KEY_CLOSE == 1)    FG_KEY_CLOSE=0;  
1359   2      
1360   2              PC_PRG();              // PC控制  
1361   2          }  
1362   1          if(Flag_test_mode == 1)
1363   1          {
1364   2              Flag_test_mode = 0;
1365   2              UART1_end();
1366   2          }
1367   1          PIN_POWER_CONTROL = 0;
1368   1          PIN_TX_LED = 0;
1369   1          FG_KEY_OPEN = 0;
1370   1          FG_KEY_STOP = 0;
1371   1          FG_KEY_CLOSE = 0;  
1372   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5481    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     38    ----
   IDATA SIZE       =      1    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
